/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./javascript/index.js":
/*!*****************************!*\
  !*** ./javascript/index.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mouse: () => (/* binding */ mouse)\n/* harmony export */ });\n/* harmony import */ var _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @harxer/geometry */ \"./node_modules/@harxer/geometry/lib/geometry.js\");\n/* harmony import */ var _harxer_engine_2d_helpers_layout_Layout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @harxer/engine-2d/helpers/layout/Layout.js */ \"./node_modules/@harxer/engine-2d/helpers/layout/Layout.js\");\n/* harmony import */ var _harxer_engine_2d_helpers_layout_tools_LayoutManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @harxer/engine-2d/helpers/layout/tools/LayoutManager.js */ \"./node_modules/@harxer/engine-2d/helpers/layout/tools/LayoutManager.js\");\n/* harmony import */ var _log_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./log.js */ \"./javascript/log.js\");\n/* harmony import */ var _harxer_engine_2d_core_TickClock_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @harxer/engine-2d/core/TickClock.js */ \"./node_modules/@harxer/engine-2d/core/TickClock.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// ==================================================================================================================== Variables =====\r\nconst RENDER_SCALING = 2\r\nconst RENDER_HERTZ = 30\r\nconst view = {\r\n  x: 0,\r\n  y: 0\r\n}\r\n\r\nlet canvasFlush = true // if drawing frames are cleared or retained\r\nlet canvas_bg = document.getElementById(\"bgCanvas\")\r\nlet canvasMasterContext = canvas_bg.getContext('2d') // The primary canvas particles are drawn on\r\n/** @type {Layout} */\r\nlet layout2D = undefined;\r\n\r\nconst MOUSE_TOOL = {\r\n  POINTER: 0,\r\n  MESH_CONSTRUCTOR: 1,\r\n  MESH_ERASER: 2,\r\n  PATHER: 3\r\n}\r\n\r\nlet mouse = {\r\n  loc: new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0),\r\n  lastLeftClick: undefined,\r\n  lastRightClick: undefined,\r\n  tool: MOUSE_TOOL.POINTER,\r\n  get contextLoc() {\r\n    return new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(this.loc.x - view.x, this.loc.y - view.y)\r\n  },\r\n  labelVisible: false\r\n}\r\n// Set default toolbox selection to pointer\r\ndocument.getElementById('settings-item-toolbox-pointer').className = 'active';\r\n/** 0 - no mouse drag, 1 - left mouse drag, 2 - right mouse drag */\r\nlet canvasMouseDragging = 0;\r\n\r\ncanvas_bg.width = RENDER_SCALING * canvas_bg.offsetWidth;\r\ncanvas_bg.height = RENDER_SCALING * canvas_bg.offsetHeight;\r\n\r\n// ================================================================================================ Settings Initialization =====\r\nconst SETTING_TOGGLE_ELEMENTS_MAP = {\r\n  'setting-item-updateToggle': toggleCanvasRunning,\r\n  'setting-item-mouseLabelToggle': toggleMouseLabel,\r\n  'setting-item-smearToggle': toggleSmearRendering,\r\n  // Triangulate settings\r\n  'setting-item-triangulate-highlight-edges': toggleTriangulateHighlightEdges,\r\n  'setting-item-triangulate-optimize-pass': _ => {}\r\n}\r\nObject.keys(SETTING_TOGGLE_ELEMENTS_MAP).forEach(\r\n  elemId => document.getElementById(elemId).addEventListener('click', e => {\r\n    e.target.classList.toggle(\"active\");\r\n    SETTING_TOGGLE_ELEMENTS_MAP[elemId](e);\r\n    e.preventDefault();\r\n  })\r\n)\r\n\r\nconst SETTING_BUTTON_ELEMENTS_MAP = {\r\n  'setting-item-mesh-reset': resetLayout,\r\n  'setting-item-mesh-load': loadLayout,\r\n  'setting-item-mesh-print': printLayout,\r\n  'setting-item-console-clear': _log_js__WEBPACK_IMPORTED_MODULE_3__.clear,\r\n  'setting-item-randomPath': randomPath,\r\n  'setting-item-hide-control-window': hideControlWindow\r\n}\r\nObject.keys(SETTING_BUTTON_ELEMENTS_MAP).forEach(\r\n  elemId => document.getElementById(elemId).addEventListener('click', e => {\r\n    SETTING_BUTTON_ELEMENTS_MAP[elemId](e);\r\n    e.preventDefault();\r\n  })\r\n)\r\n\r\n// -------------- Dev pane resizing setup\r\nlet devPaneContentResizing = false;\r\ndocument.getElementById('dev-pane-content-divider').onmousedown = e => {\r\n  devPaneContentResizing = true;\r\n}\r\nconst ELEMENT_DEV_PANE = document.getElementById('dev-pane');\r\nconst ELEMENT_DEV_PANE_CONTROL_SETTINGS = document.getElementById('dev-pane-controls-settings');\r\nELEMENT_DEV_PANE.onmousemove = e => {\r\n  if (!devPaneContentResizing) return;\r\n  let scrollY = (e.target.getBoundingClientRect().top + e.offsetY) - ELEMENT_DEV_PANE.offsetTop - 10;\r\n  // ELEMENT_DEV_PANE_CONTROL_SETTINGS.style.height = `${scrollY / ELEMENT_DEV_PANE.offsetHeight * 100}%`\r\n  ELEMENT_DEV_PANE_CONTROL_SETTINGS.style.height = `${scrollY}px`\r\n  e.preventDefault();\r\n}\r\ndocument.addEventListener('mouseup', e => {\r\n  devPaneContentResizing = false;\r\n})\r\n// --------------\r\n\r\nfunction toggleCanvasRunning() {\r\n  _harxer_engine_2d_core_TickClock_js__WEBPACK_IMPORTED_MODULE_4__.running() ? _harxer_engine_2d_core_TickClock_js__WEBPACK_IMPORTED_MODULE_4__.stop() : _harxer_engine_2d_core_TickClock_js__WEBPACK_IMPORTED_MODULE_4__.resume();\r\n}\r\nfunction toggleMouseLabel() {\r\n  mouse.labelVisible = !mouse.labelVisible\r\n}\r\nfunction toggleSmearRendering() {\r\n  canvasFlush = !canvasFlush\r\n}\r\nfunction randomPath() {\r\n  let { point: p1 } = layout2D.meshContext.getRandomPoint();\r\n  let { point: p2 } = layout2D.meshContext.getRandomPoint();\r\n  testCircle(p1.x, p1.y, 6, true)\r\n  testCircle(p2.x, p2.y, 6)\r\n  _harxer_engine_2d_helpers_layout_tools_LayoutManager_js__WEBPACK_IMPORTED_MODULE_2__.setPathfindingRoute(\r\n    layout2D.contextRoute(p1, p2)\r\n  );\r\n}\r\n\r\nfunction toggleTriangulateHighlightEdges(e) {\r\n  _harxer_engine_2d_helpers_layout_tools_LayoutManager_js__WEBPACK_IMPORTED_MODULE_2__.triangulationVisible(!_harxer_engine_2d_helpers_layout_tools_LayoutManager_js__WEBPACK_IMPORTED_MODULE_2__.visibleTriangulation)\r\n}\r\ndocument.getElementById('modal-layout-load-close').addEventListener('click', _ => {\r\n  document.getElementById('modal-layout-load').style.display = 'none';\r\n})\r\ndocument.getElementById('modal-layout-button-load').addEventListener('click', _ => {\r\n  let inputElement = document.getElementById('modal-layout-load-input');\r\n  layout2D = _harxer_engine_2d_helpers_layout_Layout_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromJson(inputElement.value);\r\n  inputElement.value = '';\r\n  document.getElementById('modal-layout-load').style.display = 'none';\r\n})\r\nfunction hideControlWindow(e) {\r\n  if (document.getElementById('dev-pane').classList.contains(\"hidden\")) {\r\n    e.target.innerHTML = \"Minimize Dev Pane\";\r\n  } else {\r\n    e.target.innerHTML = \"Maximize Dev Pane\";\r\n  }\r\n  document.getElementById('dev-pane').classList.toggle(\"hidden\");\r\n  document.getElementById('dev-pane-controls-settings').classList.toggle(\"hidden\");\r\n}\r\nfunction loadLayout() {\r\n  document.getElementById('modal-layout-load').style.display = 'block';\r\n}\r\nfunction resetLayout() {\r\n  _harxer_engine_2d_helpers_layout_tools_LayoutManager_js__WEBPACK_IMPORTED_MODULE_2__.reloadDefaultLayout().then(layout => layout2D = layout);\r\n}\r\nfunction printLayout() {\r\n  (0,_log_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(layout2D.serialized())\r\n  if (mouse.tool === MOUSE_TOOL.PATHER) {\r\n    (0,_log_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(`Left mouse: ${mouse.lastLeftClick?.logString()}. Right mouse: ${mouse.lastRightClick?.logString()}`)\r\n  }\r\n}\r\n\r\nfunction handleToolboxClick(e) {\r\n  for (const child of document.getElementById('settings-item-toolbox-buttons').children) {\r\n    child.className = \"\"\r\n  }\r\n  e.target.className = \"active\";\r\n  if (e.target.id === 'settings-item-toolbox-pointer') {\r\n    mouse.tool = MOUSE_TOOL.POINTER;\r\n  } else\r\n  if (e.target.id === 'settings-item-toolbox-constructor') {\r\n    mouse.tool = MOUSE_TOOL.MESH_CONSTRUCTOR;\r\n  } else\r\n  if (e.target.id === 'settings-item-toolbox-eraser') {\r\n    mouse.tool = MOUSE_TOOL.MESH_ERASER;\r\n  } else\r\n  if (e.target.id === 'settings-item-toolbox-pather') {\r\n    mouse.tool = MOUSE_TOOL.PATHER;\r\n  }\r\n}\r\ndocument.getElementById('settings-item-toolbox-pointer').addEventListener('click', handleToolboxClick)\r\ndocument.getElementById('settings-item-toolbox-constructor').addEventListener('click', handleToolboxClick)\r\ndocument.getElementById('settings-item-toolbox-eraser').addEventListener('click', handleToolboxClick)\r\ndocument.getElementById('settings-item-toolbox-pather').addEventListener('click', handleToolboxClick)\r\n\r\n// =================================================================================================================== Test rendering =====\r\nlet test_points = [];\r\nlet test_lines = [];\r\nlet test_circles = [];\r\n\r\nlet contentOut = document.getElementById(\"content-output\")\r\nlet contentOutScrolling = false\r\nlet contentOutTrackLastMouseMove = 0\r\nconst CONTENT_OUT_SCROLL_SPEED = 1\r\n;(0,_log_js__WEBPACK_IMPORTED_MODULE_3__.attachLogOut)(contentOut)\r\ncontentOut.onmousemove = e => {\r\n  let offsetY = contentOut.offsetTop\r\n  contentOutTrackLastMouseMove = e.clientY - offsetY\r\n  contentOutScrolling = (e.clientY > offsetY + contentOut.offsetHeight - 30);\r\n}\r\ncontentOut.onmouseleave = () => {\r\n  contentOutScrolling = false;\r\n}\r\ncontentOut.onscroll = () => {\r\n  let y = contentOutTrackLastMouseMove + contentOut.scrollTop\r\n  let listItems = contentOut.children\r\n  for (let i = 0; i < listItems.length; i++) {\r\n    let listItem = listItems[i]\r\n    if (listItem.offsetTop < y && listItem.offsetTop + listItem.offsetHeight > y) {\r\n      listItem.dispatchEvent(new Event('mouseenter'))\r\n      break\r\n    }\r\n  }\r\n}\r\n\r\nfunction testLine(a, b, flush = false) {\r\n  if (flush) test_lines = []\r\n  test_lines.push( {a: a, b: b, color: \"rgb(44,54,64)\"} );\r\n}\r\nfunction testPoint(x, y, flush = false) {\r\n  if (flush) test_points = []\r\n  test_points.push( {x: x, y: y, color:  \"rgb(44,54,64)\"} );\r\n}\r\nfunction testCircle(x, y, r, flush = false) {\r\n  if (flush) test_circles = []\r\n  test_circles.push( {x: x, y: y, r: r, color:  \"rgb(44,54,64)\"});\r\n}\r\nfunction renderTestShapes() {\r\n  test_circles.forEach(circle => {\r\n    canvasMasterContext.strokeStyle = circle.color;\r\n    canvasMasterContext.beginPath();\r\n    canvasMasterContext.arc(circle.x, circle.y, circle.r, 0, 2 * Math.PI, false);\r\n    canvasMasterContext.stroke();\r\n  });\r\n  test_lines.forEach(line => {\r\n    canvasMasterContext.strokeStyle = line.color;\r\n    canvasMasterContext.beginPath();\r\n    canvasMasterContext.moveTo(line.a.x, line.a.y);\r\n    canvasMasterContext.lineTo(line.b.x, line.b.y);\r\n    canvasMasterContext.stroke();\r\n  })\r\n  test_points.forEach(point => {\r\n    canvasMasterContext.fillStyle = point.color;\r\n    canvasMasterContext.beginPath();\r\n    canvasMasterContext.arc(point.x, point.y, 4, 0, 2 * Math.PI, false);\r\n    canvasMasterContext.fill();\r\n  })\r\n  if (mouse.labelVisible) {\r\n    canvasMasterContext.fillStyle = \"black\"\r\n    canvasMasterContext.font = '20px sans-serif';\r\n    canvasMasterContext.fillText(mouse.contextLoc.x+', '+mouse.contextLoc.y, mouse.contextLoc.x+5, mouse.contextLoc.y-5);\r\n  }\r\n  if (mouse.tool === MOUSE_TOOL.MESH_CONSTRUCTOR) {\r\n    canvasMasterContext.strokeStyle = \"black\"\r\n    canvasMasterContext.lineWidth = 3;\r\n    canvasMasterContext.beginPath();\r\n    canvasMasterContext.moveTo(mouse.contextLoc.x - 20, mouse.contextLoc.y);\r\n    canvasMasterContext.lineTo(mouse.contextLoc.x + 20, mouse.contextLoc.y);\r\n    canvasMasterContext.moveTo(mouse.contextLoc.x, mouse.contextLoc.y - 20);\r\n    canvasMasterContext.lineTo(mouse.contextLoc.x, mouse.contextLoc.y + 20);\r\n    canvasMasterContext.stroke();\r\n    canvasMasterContext.lineWidth = 1;\r\n  }\r\n  canvasMasterContext.strokeStyle = \"rgb(20, 180, 20)\";\r\n  canvasMasterContext.fillStyle = \"rgb(20, 180, 20)\";\r\n  canvasMasterContext.font = '16px sans-serif';\r\n\r\n  (0,_log_js__WEBPACK_IMPORTED_MODULE_3__.renderLogData)(canvasMasterContext)\r\n}\r\n\r\n// ======================================================================================================================== Clock =====\r\n\r\nfunction render() {\r\n  if (canvasFlush) {\r\n    canvasMasterContext.clearRect(-view.x, -view.y, canvas_bg.width, canvas_bg.height)\r\n  }\r\n\r\n  _harxer_engine_2d_helpers_layout_tools_LayoutManager_js__WEBPACK_IMPORTED_MODULE_2__.constructionRender(canvasMasterContext)\r\n  _harxer_engine_2d_helpers_layout_tools_LayoutManager_js__WEBPACK_IMPORTED_MODULE_2__.renderTriangulation(layout2D, canvasMasterContext)\r\n  if (contentOutScrolling) contentOut.scrollTop += CONTENT_OUT_SCROLL_SPEED\r\n\r\n  renderTestShapes()\r\n}\r\n\r\n// ======================================================================================================================= Window Setup =====\r\nconst KEY_CODE = {\r\n  ARROW_UP: 38,\r\n  ARROW_RIGHT: 39,\r\n  ARROW_DOWN: 40,\r\n  ARROW_LEFT: 37,\r\n  SPACEBAR: 32,\r\n  G: 71,\r\n  E: 69,\r\n  M: 77,\r\n  P: 80,\r\n  R: 82,\r\n  S: 83,\r\n  V: 86\r\n}\r\nconst handleKeyDown = keyDownEvent => {\r\n  keyDownEvent = keyDownEvent || window.event;\r\n  // log(`Log key: ${keyDownEvent.keyCode}`)\r\n  switch(keyDownEvent.keyCode) {\r\n    case KEY_CODE.ARROW_UP:\r\n      (0,_log_js__WEBPACK_IMPORTED_MODULE_3__.selectLogPrev)();\r\n      keyDownEvent.preventDefault()\r\n      break;\r\n    case KEY_CODE.ARROW_DOWN:\r\n      (0,_log_js__WEBPACK_IMPORTED_MODULE_3__.selectLogNext)();\r\n      keyDownEvent.preventDefault()\r\n      break;\r\n    case KEY_CODE.SPACEBAR:\r\n      document.getElementById('setting-item-updateToggle').click();\r\n      break;\r\n    case KEY_CODE.V:\r\n      let childElements = Array.from(document.getElementById('settings-item-toolbox-buttons').children);\r\n      let iActive = childElements.findIndex(child => child.classList.contains('active'))\r\n      iActive = (iActive + 1) % childElements.length;\r\n      childElements[iActive].click();\r\n      break;\r\n  }\r\n}\r\ndocument.addEventListener('keydown', handleKeyDown)\r\n\r\ncanvas_bg.onmousedown = e => {\r\n  if (e.button === 0) { // Left click\r\n    mouse.lastLeftClick = mouse.loc.copy;\r\n  } else { // Right click\r\n    mouse.lastRightClick = mouse.loc.copy;\r\n  }\r\n\r\n  if (mouse.tool === MOUSE_TOOL.MESH_CONSTRUCTOR) {\r\n\r\n    if (e.button === 0) {  // Left click add vertex or finish mesh if closed shape\r\n      _harxer_engine_2d_helpers_layout_tools_LayoutManager_js__WEBPACK_IMPORTED_MODULE_2__.addConstructionPoint(layout2D, mouse.contextLoc);\r\n    } else { // Right click take back last constructor vertex\r\n      _harxer_engine_2d_helpers_layout_tools_LayoutManager_js__WEBPACK_IMPORTED_MODULE_2__.undoConstructionPoint();\r\n    }\r\n\r\n  } else if (mouse.tool === MOUSE_TOOL.MESH_ERASER) {\r\n\r\n    if (layout2D.deleteMeshUnderPoint(mouse.contextLoc)) {\r\n      _harxer_engine_2d_helpers_layout_tools_LayoutManager_js__WEBPACK_IMPORTED_MODULE_2__.writeLayout(layout2D);\r\n    }\r\n\r\n  } else if (mouse.tool === MOUSE_TOOL.POINTER) {\r\n\r\n    if (e.button === 0) { // Left click\r\n      console.log(`Loc:`, mouse.contextLoc)\r\n      layout2D.contextSelection(mouse.contextLoc);\r\n    } else { // Right click\r\n      canvasMouseDragging = 2;\r\n    }\r\n\r\n  } else if (mouse.tool === MOUSE_TOOL.PATHER) {\r\n\r\n    canvasMouseDragging = e.button === 0 ? 1 : 2;\r\n\r\n    let contextLeftMouse, contextRightMouse;\r\n\r\n    if (mouse.lastLeftClick) {\r\n      contextLeftMouse = mouse.lastLeftClick.copy.minus(view);\r\n      testCircle(contextLeftMouse.x, contextLeftMouse.y, 6, true)\r\n    }\r\n    if (mouse.lastRightClick) {\r\n      contextRightMouse = mouse.lastRightClick.copy.minus(view);\r\n      testCircle(contextRightMouse.x, contextRightMouse.y, 6)\r\n    }\r\n\r\n    if (mouse.lastLeftClick && mouse.lastRightClick) {\r\n      _harxer_engine_2d_helpers_layout_tools_LayoutManager_js__WEBPACK_IMPORTED_MODULE_2__.setPathfindingRoute(\r\n        layout2D.contextRoute(contextLeftMouse, contextRightMouse)\r\n      );\r\n    }\r\n\r\n  }\r\n\r\n  e.preventDefault();\r\n}\r\n\r\ncanvas_bg.onmousemove = e => {\r\n  e.preventDefault()\r\n  let rect = canvas_bg.getBoundingClientRect();\r\n  mouse.loc = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(RENDER_SCALING * Math.floor(e.clientX - rect.left), RENDER_SCALING * (e.clientY - rect.top))\r\n\r\n  if (canvasMouseDragging > 0) {\r\n    if (mouse.tool === MOUSE_TOOL.POINTER) {\r\n      let x = mouse.loc.x - mouse.lastRightClick.x;\r\n      let y = mouse.loc.y - mouse.lastRightClick.y;\r\n      mouse.lastRightClick = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(mouse.loc.x, mouse.loc.y)\r\n      canvasMasterContext.translate(x, y)\r\n      view.x += x\r\n      view.y += y\r\n    } else if (mouse.tool === MOUSE_TOOL.PATHER) {\r\n      if (canvasMouseDragging === 1) { // Left click\r\n        mouse.lastLeftClick = mouse.loc.copy;\r\n      } else { // Right click\r\n        mouse.lastRightClick = mouse.loc.copy;\r\n      }\r\n\r\n      (0,_log_js__WEBPACK_IMPORTED_MODULE_3__.disableLogging)(true);\r\n\r\n      let contextLeftMouse = mouse.lastLeftClick.copy.minus(view);\r\n      let contextRightMouse = mouse.lastRightClick.copy.minus(view);\r\n      testCircle(contextLeftMouse.x, contextLeftMouse.y, 6, true)\r\n      testCircle(contextRightMouse.x, contextRightMouse.y, 6)\r\n\r\n      _harxer_engine_2d_helpers_layout_tools_LayoutManager_js__WEBPACK_IMPORTED_MODULE_2__.setPathfindingRoute(\r\n        layout2D.contextRoute(contextLeftMouse, contextRightMouse)\r\n      );\r\n    }\r\n  } else {\r\n    if (mouse.tool === MOUSE_TOOL.MESH_CONSTRUCTOR) {\r\n      _harxer_engine_2d_helpers_layout_tools_LayoutManager_js__WEBPACK_IMPORTED_MODULE_2__.constructionMouseMoveHandler(mouse.contextLoc.x, mouse.contextLoc.y)\r\n    }\r\n  }\r\n}\r\n\r\ncanvas_bg.onmouseup = e => {\r\n  canvasMouseDragging = false;\r\n  (0,_log_js__WEBPACK_IMPORTED_MODULE_3__.disableLogging)(false);\r\n}\r\n\r\ncanvas_bg.oncontextmenu = e => e.preventDefault()\r\n\r\nwindow.onresize = () => homeRefit()\r\n\r\nfunction homeRefit() {\r\n  // Each time the height or width of a canvas is set,\r\n  // the canvas transforms will be cleared.\r\n  let transform = canvasMasterContext.getTransform()\r\n\r\n  // Sync canvas size\r\n  canvas_bg.width = canvas_bg.offsetWidth * RENDER_SCALING;\r\n  canvas_bg.height = canvas_bg.offsetHeight * RENDER_SCALING;\r\n\r\n  // Apply preserved context transformations\r\n  canvasMasterContext.setTransform(transform)\r\n}\r\n\r\n// ======================================================================================================================= Launch =====\r\n\r\n{\r\n  homeRefit()\r\n  _harxer_engine_2d_helpers_layout_tools_LayoutManager_js__WEBPACK_IMPORTED_MODULE_2__.setLayoutCookieKey('js-2d-pathing-layout')\r\n  _harxer_engine_2d_helpers_layout_tools_LayoutManager_js__WEBPACK_IMPORTED_MODULE_2__.setDefaultJsonLayoutUrl('layout_default.json')\r\n  layout2D = new _harxer_engine_2d_helpers_layout_Layout_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\r\n  _harxer_engine_2d_helpers_layout_tools_LayoutManager_js__WEBPACK_IMPORTED_MODULE_2__.initLayout().then(layout => {\r\n    layout2D = layout;\r\n  });\r\n\r\n  _harxer_engine_2d_core_TickClock_js__WEBPACK_IMPORTED_MODULE_4__.addInterval('render', render, RENDER_HERTZ)\r\n  _harxer_engine_2d_core_TickClock_js__WEBPACK_IMPORTED_MODULE_4__.start()\r\n\r\n  document.getElementById('setting-item-hide-control-window').click();\r\n}\r\n\n\n//# sourceURL=webpack://js-2d-pathing/./javascript/index.js?");

/***/ }),

/***/ "./javascript/log.js":
/*!***************************!*\
  !*** ./javascript/log.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   attachLogOut: () => (/* binding */ attachLogOut),\n/* harmony export */   clear: () => (/* binding */ clear),\n/* harmony export */   \"default\": () => (/* binding */ log),\n/* harmony export */   disableLogging: () => (/* binding */ disableLogging),\n/* harmony export */   renderLogData: () => (/* binding */ renderLogData),\n/* harmony export */   selectLogNext: () => (/* binding */ selectLogNext),\n/* harmony export */   selectLogPrev: () => (/* binding */ selectLogPrev)\n/* harmony export */ });\n/* harmony import */ var _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @harxer/geometry */ \"./node_modules/@harxer/geometry/lib/geometry.js\");\n/* harmony import */ var _harxer_engine_2d_helpers_layout_Mesh_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @harxer/engine-2d/helpers/layout/Mesh.js */ \"./node_modules/@harxer/engine-2d/helpers/layout/Mesh.js\");\n\r\n\r\n\r\nlet logData = []\r\nlet logSelected = undefined\r\nlet loggingDisabled = false\r\n/**\r\n * Override logging globally. Useful for capturing logs under a certain condition.\r\n */\r\nfunction disableLogging(val) {\r\n  loggingDisabled = val\r\n}\r\n\r\nlet contentOut = undefined\r\n/**\r\n * Setup on-screen log out with a ul element for text output.\r\n *\r\n * @param {ul} list_element html element of list type to push text list items to\r\n */\r\nfunction attachLogOut(list_element) {\r\n  contentOut = list_element\r\n}\r\n\r\nfunction clear() {\r\n  if (!contentOut) throw 'Logging was not configured with a list element with setup() call'\r\n  logSelected = undefined\r\n  contentOut.innerHTML = \"\";\r\n  logData = []\r\n}\r\n\r\n/**\r\n * Text is required and will be placed into the output list in its own list item.\r\n * Optional parameter 'data' can be an array with segments, points, vectors, rays, and polygons.\r\n * Passing true or false into the optional 'flush' argument will clear all output before printing the text.\r\n */\r\nfunction log(text, data, flush) {\r\n  if (loggingDisabled) return\r\n  if (!contentOut) throw 'Logging was not configured with a list element with setup() call'\r\n\r\n  // Optional(overloaded) parameter handling...\r\n  if (!Array.isArray(data)) {\r\n    if (typeof data == typeof true) flush = data;\r\n    data = [];\r\n  } else flush = flush || false;\r\n  let li = document.createElement(\"li\");\r\n\r\n  // Clone data objects\r\n  data = data.map(d => d.copy);\r\n\r\n  li.innerHTML = text;\r\n  li.onmouseenter = () => {\r\n    if (logSelected === undefined) logData = data\r\n  }\r\n  li.onmousedown = () => {\r\n    if (logSelected !== undefined) logSelected.style.backgroundColor = \"\"\r\n    if (li === logSelected) logSelected = undefined\r\n    else {\r\n      logData = data\r\n      logSelected = li\r\n      logSelected.style.backgroundColor = \"darkgray\"\r\n    }\r\n  }\r\n  li.onmouseleave = () => {\r\n    if (logSelected === undefined) logData = []\r\n  }\r\n  if (flush) {\r\n    logSelected = undefined\r\n    contentOut.innerHTML = \"\";\r\n    logData = []\r\n  }\r\n  contentOut.appendChild(li);\r\n  // console.log(text)\r\n}\r\n\r\nconst getLogSelectedIndex = () => {\r\n  if (logSelected === undefined) return undefined\r\n  let items = contentOut.children\r\n  for (let c = 0; c < items.length; c++) {\r\n    if (items[c] === logSelected) {\r\n      return c\r\n    }\r\n  }\r\n}\r\nfunction selectLogPrev() {\r\n  let c = getLogSelectedIndex()\r\n  if (c === undefined || c == 0) return\r\n  contentOut.children[c - 1].dispatchEvent(new Event('mousedown'));\r\n  syncContentOutHeight(contentOut.children[c - 1])\r\n}\r\n\r\nfunction selectLogNext() {\r\n  let c = getLogSelectedIndex()\r\n  if (c === undefined || c == contentOut.children.length - 1) return\r\n  contentOut.children[c + 1].dispatchEvent(new Event('mousedown'));\r\n  syncContentOutHeight(contentOut.children[c+1])\r\n}\r\n\r\nfunction syncContentOutHeight(child) {\r\n  let y = child.offsetTop - contentOut.offsetTop;\r\n  if (y - 2 * child.offsetHeight < contentOut.scrollTop) {\r\n    contentOut.scrollTop = y - 2 * child.offsetHeight;\r\n  } else if (y + child.offsetHeight > contentOut.scrollTop + contentOut.offsetHeight) {\r\n    contentOut.scrollTop = y + child.offsetHeight - contentOut.offsetHeight;\r\n  }\r\n}\r\n\r\nfunction renderLogData(context) {\r\n  logData.forEach((data, i) => {\r\n    if (data instanceof _harxer_engine_2d_helpers_layout_Mesh_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\r\n      data = data.polygon\r\n    } else\r\n    if (data instanceof _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Vector) {\r\n      data = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(data.x(), data.y())\r\n    }\r\n\r\n    if (_harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment.typeOf(data)) {\r\n      context.beginPath()\r\n      context.arc(data.a.x, data.a.y, 4, 0, 2 * Math.PI, false)\r\n      context.stroke()\r\n      context.beginPath()\r\n      context.arc(data.b.x, data.b.y, 4, 0, 2 * Math.PI, false)\r\n      context.fill()\r\n      context.beginPath()\r\n      context.moveTo(data.a.x, data.a.y)\r\n      context.lineTo(data.b.x, data.b.y)\r\n      context.stroke()\r\n      context.fillText(`${i}: ${data.a.logString()}`, data.a.x+5, data.a.y - 5)\r\n      context.fillText(data.b.logString(), data.b.x+5, data.b.y - 5)\r\n    } else\r\n    if (_harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.typeOf(data)) {\r\n      context.beginPath();\r\n      context.arc(data.x, data.y, 4, 0, 2 * Math.PI, false);\r\n      context.fill();\r\n      context.fillText(`${i}: ${data.logString()}`, data.x + 5, data.y - 5);\r\n    } else\r\n    if (data instanceof _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Polygon) {\r\n      data.vertices.forEach((vertex, vIndex) => {\r\n        let cirleRadius = vIndex == 1 || vIndex == 0 ? 4 : 2\r\n        context.beginPath();\r\n        context.arc(vertex.x, vertex.y, cirleRadius, 0, 2 * Math.PI, false);\r\n        if (vIndex == 0) context.stroke();\r\n        else context.fill()\r\n      })\r\n      context.fillStyle = \"rgba(20, 180, 20, 0.2)\";\r\n      context.beginPath();\r\n      context.moveTo(data.vertices[0].x, data.vertices[0].y);\r\n      data.vertices.forEach(vertex => context.lineTo(vertex.x, vertex.y))\r\n      context.lineTo(data.vertices[0].x, data.vertices[0].y);\r\n      if (data.clockwise) context.fill()\r\n      context.stroke();\r\n    }\r\n  })\r\n}\r\n\r\nwindow.onerror = (message, url, linenumber) => {\r\n  let file = url.substring(url.lastIndexOf('/') + 1)\r\n  log(`${file}:${linenumber} - ${message}`, false)\r\n}\r\n\n\n//# sourceURL=webpack://js-2d-pathing/./javascript/log.js?");

/***/ }),

/***/ "./node_modules/@harxer/engine-2d/core/Input.js":
/*!******************************************************!*\
  !*** ./node_modules/@harxer/engine-2d/core/Input.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InputInitializer: () => (/* binding */ InputInitializer),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @harxer/geometry */ \"./node_modules/@harxer/geometry/lib/geometry.js\");\n/**\r\n * Input handler.\r\n *\r\n * @export InputReader - Retrieve input buffers here.\r\n *\r\n * @export InputInitializer - Setup mouse and key listeners. Mouse interactions need to\r\n * be attached to an HTML element that emits mousemove events `(InputInitializer.initMouseListener(<html element>))`.\r\n * Key actions are assigned callbacks using `InputInitializer.setKeyAction(InputReader.KEYCODE.<key>, callback)`.\r\n *\r\n * @usage\r\n *\r\n * @author Harrison Balogh\r\n */\r\n\r\n\r\nconst UPDATE = 0\r\nconst SYNC = 1\r\n\r\nconst InputReader = {\r\n  KEYCODE: {\r\n    LEFT: 65,\r\n    UP: 87,\r\n    RIGHT: 68,\r\n    DOWN: 83,\r\n    LEFT_ALT: 37,\r\n    UP_ALT: 38,\r\n    RIGHT_ALT: 39,\r\n    DOWN_ALT: 40,\r\n    SPACEBAR: 32,\r\n    I: 73,\r\n    O: 79,\r\n    K: 75,\r\n    L: 76,\r\n    P: 80,\r\n    R: 82,\r\n    ESC: 27\r\n  },\r\n  isKeyPressed: (keyCode) => {\r\n    let key = input.key[keyCode]\r\n    if (key === undefined) return undefined\r\n    return key.down\r\n  },\r\n  isMouseDown: () => {\r\n    return input.mouse.down\r\n  },\r\n  isMouseWithShift: () => {\r\n    return input.mouse.withShift\r\n  },\r\n  mouseLocation: () => {\r\n    return { x: input.mouse.x, y: input.mouse.y }\r\n  },\r\n  playerInputVectorUpdate: timestamp => InputPlayerHandler.inputVector(timestamp, UPDATE),\r\n  playerInputVectorSync: timestamp => InputPlayerHandler.inputVector(timestamp, SYNC),\r\n}\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InputReader);\r\n\r\nconst KeyListenerData = () => ({ down: 0, actionsPress: [], actionsRelease: [] })\r\nlet input = {\r\n  key: { /** keycode: KeyListenerData */ },\r\n  mouse: {\r\n    x: 0, y: 0,\r\n    down: false,\r\n    withShift: false,\r\n    downAction: () => { },\r\n    buttons: {}\r\n  }\r\n}\r\nlet handleMouseEvent = e => {\r\n  // console.log(`Mouse ${e.type}`)\r\n  input.mouse.withShift = e.shiftKey\r\n  input.mouse.down = (e.type == \"mousedown\")\r\n  input.mouse.buttons[e.button] = (e.type == \"mousedown\")\r\n  if (input.mouse.down) input.mouse.downAction(input.mouse.x, input.mouse.y)\r\n}\r\n\r\nconst handleKeyPress = keyEvent => {\r\n  keyEvent = keyEvent || window.event;\r\n  // console.log(`Key down: ${keyEvent.keyCode}`)\r\n  let handledKey = input.key[keyEvent.keyCode]\r\n  if (handledKey == undefined) return\r\n\r\n  if (handledKey.down && keyEvent.type == 'keydown') return // Ignore repeats\r\n\r\n  let actionData = { timeStamp: keyEvent.timeStamp, keyCode: keyEvent.keyCode }\r\n  if (keyEvent.type == 'keydown') {\r\n    handledKey.down = keyEvent.timeStamp\r\n    handledKey.actionsPress.forEach(action => action(actionData))\r\n  }\r\n  if (keyEvent.type == 'keyup') {\r\n    handledKey.actionsRelease.forEach(action => action(actionData))\r\n    handledKey.down = 0 // Key up from window event clears key press time\r\n  }\r\n}\r\n\r\nconst InputInitializer = {\r\n  /**\r\n   * Adds a callback to the given KeyCode press/release\r\n   * @param {*} keyCode\r\n   * @param {*} action\r\n   * @returns\r\n   */\r\n  addKeyAction: (keyCode, action, forPress = false, forRelease = true) => {\r\n    if (typeof action !== 'function') return\r\n    let key = input.key[keyCode]\r\n    if (key === undefined) {\r\n      input.key[keyCode] = KeyListenerData()\r\n      key = input.key[keyCode]\r\n    }\r\n    if (forPress) key.actionsPress.push(action)\r\n    if (forRelease) key.actionsRelease.push(action)\r\n  },\r\n  /**\r\n   * Initialize mouse listeners relative to given HTML element.\r\n   *\r\n   * @param {HMTL Element} element bounding HTML element to add mouse listeners\r\n   */\r\n  initMouseListener: (element, mouseDownAction) => {\r\n    if (typeof mouseDownAction === 'function') input.mouse.downAction = mouseDownAction\r\n    element.addEventListener('mousemove', e => {\r\n      var rect = element.getBoundingClientRect()\r\n      input.mouse.x = Math.floor(e.clientX - rect.left)\r\n      input.mouse.y = (e.clientY - rect.top)\r\n    })\r\n    element.addEventListener('mouseup', handleMouseEvent)\r\n    element.addEventListener('mousedown', handleMouseEvent)\r\n    element.oncontextmenu = e => e.preventDefault();\r\n  },\r\n  initKeyListener: () => {\r\n    window.addEventListener('keydown', handleKeyPress)\r\n    window.addEventListener('keyup', handleKeyPress)\r\n  },\r\n  initInputPlayerHandler: () => InputPlayerHandler.init(),\r\n  cleanup: element => {\r\n    element.removeEventListener('mouseup', handleMouseEvent)\r\n    element.removeEventListener('mousedown', handleMouseEvent)\r\n    window.removeEventListener('keydown', handleKeyPress)\r\n    window.removeEventListener('keyup', handleKeyPress)\r\n  }\r\n}\r\n\r\n/** Support for player input handling. LEFT/RIGHT/UP/DOWN input buffering\r\n * Need to call init (from InputInitializer) to setup properly.\r\n*/\r\nconst InputPlayerHandler = {\r\n  bufferInputs: Array(2).fill({ x: 0, y: 0 }), // Use for: 0 - 'updateTick' and 1 - 'syncTick'\r\n\r\n  init: () => {\r\n    InputInitializer.addKeyAction(InputReader.KEYCODE.RIGHT, InputPlayerHandler.captureReleaseTime, false)\r\n    InputInitializer.addKeyAction(InputReader.KEYCODE.LEFT, InputPlayerHandler.captureReleaseTime, false)\r\n    InputInitializer.addKeyAction(InputReader.KEYCODE.UP, InputPlayerHandler.captureReleaseTime, false)\r\n    InputInitializer.addKeyAction(InputReader.KEYCODE.DOWN, InputPlayerHandler.captureReleaseTime, false)\r\n  },\r\n\r\n  /** Gets input buffered for buffer index and resets buffer.\r\n   * @returns Vector - representing aggregated key hold times (UP/DOWN/LEFT/RIGHT) since last buffer extract\r\n   */\r\n  inputVector: (timestamp, bufferIndex) => {\r\n    InputPlayerHandler.captureReleaseTimeAll(timestamp)\r\n\r\n    let inputVector = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Vector(\r\n      InputPlayerHandler.bufferInputs[bufferIndex].x / 1000,\r\n      InputPlayerHandler.bufferInputs[bufferIndex].y / 1000\r\n    )\r\n    // Clear Buffer\r\n    InputPlayerHandler.bufferInputs[bufferIndex] = { x: 0, y: 0 }\r\n\r\n    return inputVector\r\n  },\r\n\r\n  /** Helper for calling captureReleaseTime on each input key (UP/DOWN/LEFT/RIGHT) */\r\n  captureReleaseTimeAll: timeStamp => {\r\n    InputPlayerHandler.captureReleaseTime({ keyCode: InputReader.KEYCODE.LEFT, timeStamp })\r\n    InputPlayerHandler.captureReleaseTime({ keyCode: InputReader.KEYCODE.RIGHT, timeStamp })\r\n    InputPlayerHandler.captureReleaseTime({ keyCode: InputReader.KEYCODE.UP, timeStamp })\r\n    InputPlayerHandler.captureReleaseTime({ keyCode: InputReader.KEYCODE.DOWN, timeStamp })\r\n  },\r\n\r\n  /**\r\n   * Handle key release event by storing key-release time in buffers for update and sync ticks.\r\n   * Key down logic in handleKeyPress()\r\n   * @param {*} keyEvent - Passed from handleKeyPress - window event keydown\r\n   */\r\n  captureReleaseTime: keyUpEvent => {\r\n    let key = input.key[keyUpEvent.keyCode]\r\n    if (key.down == 0) return // Key not pressed\r\n\r\n    let dT = keyUpEvent.timeStamp - key.down // See handleKeyPress for keyDown time\r\n    if (dT <= 0) return // I guess?\r\n\r\n    if (keyUpEvent.keyCode === InputReader.KEYCODE.RIGHT) { // positive x time indicates moving right\r\n      InputPlayerHandler.bufferInputs.forEach(buffer => buffer.x += dT)\r\n    } else\r\n    if (keyUpEvent.keyCode === InputReader.KEYCODE.LEFT) { // negative x time indicates moving left\r\n      InputPlayerHandler.bufferInputs.forEach(buffer => buffer.x -= dT)\r\n    } else\r\n    if (keyUpEvent.keyCode === InputReader.KEYCODE.UP) { // positive y time indicates moving up\r\n      InputPlayerHandler.bufferInputs.forEach(buffer => buffer.y -= dT)\r\n    } else\r\n    if (keyUpEvent.keyCode === InputReader.KEYCODE.DOWN) { // negative y time indicates moving down\r\n      InputPlayerHandler.bufferInputs.forEach(buffer => buffer.y += dT)\r\n    }\r\n    // If pressed, move key.down timestamp to this key up event\r\n    key.down = keyUpEvent.timeStamp\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://js-2d-pathing/./node_modules/@harxer/engine-2d/core/Input.js?");

/***/ }),

/***/ "./node_modules/@harxer/engine-2d/core/TickClock.js":
/*!**********************************************************!*\
  !*** ./node_modules/@harxer/engine-2d/core/TickClock.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCallback: () => (/* binding */ addCallback),\n/* harmony export */   addInterval: () => (/* binding */ addInterval),\n/* harmony export */   disableConstantTimeStep: () => (/* binding */ disableConstantTimeStep),\n/* harmony export */   enableConstantTimeStep: () => (/* binding */ enableConstantTimeStep),\n/* harmony export */   flush: () => (/* binding */ flush),\n/* harmony export */   removeCallback: () => (/* binding */ removeCallback),\n/* harmony export */   removeInterval: () => (/* binding */ removeInterval),\n/* harmony export */   resume: () => (/* binding */ resume),\n/* harmony export */   running: () => (/* binding */ running),\n/* harmony export */   setConstantTimeStepHertz: () => (/* binding */ setConstantTimeStepHertz),\n/* harmony export */   start: () => (/* binding */ start),\n/* harmony export */   stepTick: () => (/* binding */ stepTick),\n/* harmony export */   stop: () => (/* binding */ stop),\n/* harmony export */   waitTicks: () => (/* binding */ waitTicks)\n/* harmony export */ });\n/**\r\n * Add and remove callback events to low interval timers.\r\n *\r\n * Executes tick events as fast as requestAnimationFrame allows.\r\n * Delta time and current time passed to tick events.\r\n *\r\n * @usage TickClock.addInterval('update', updateTick, 100)\r\n *\r\n * @author Harrison Balogh\r\n */\r\n\r\n/** TODO: Update ticks will not be passed time deltas longer than this value. */\r\n// let TICK_HERTZ_MIN = 1000 / 60\r\n\r\n/** Global hertz override for all intervals. Useful when capturing frames for a render. */\r\nlet _constantTimeStepOverride = false\r\n/** Allows constant time steps to be applied when manually ticking the clock. */\r\nlet _stepTicking = false;\r\nlet _constantTimeStepHertz = 60 // ms\r\nconst enableConstantTimeStep = _ => _constantTimeStepOverride = true\r\nconst disableConstantTimeStep = _ => _constantTimeStepOverride = false\r\n/** Set global constant time step hertz rate in seconds. */\r\nconst setConstantTimeStepHertz = val => _constantTimeStepHertz = val / 1000;\r\n\r\n// Animation render API setup - vendor prefixes\r\nif (typeof window !== \"undefined\") {\r\n  window.requestAnimFrame =\r\n  window.requestAnimationFrame ||\r\n  window.webkitRequestAnimationFrame ||\r\n  window.mozRequestAnimationFrame ||\r\n  window.oRequestAnimationFrame ||\r\n  window.msRequestAnimationFrame ||\r\n  (callback => window.setTimeout(callback, 1000 / 60))\r\n}\r\n\r\n/**\r\n * TickInterval object.\r\n *\r\n * @param {string} label - Unique label to identify tick interval.\r\n * @param {function(delta, timestamp)|[function(delta, timstamp)]} callback - Callback(s) to initialize interval with. Can be a singular function or array of functions\r\n * @param {int} hertz - Target executions per seconds. Defaults to zero for fastest tick rate.\r\n */\r\nclass TickInterval {\r\n  constructor(label, callback = [], hertz = 0) {\r\n    this.label = label;\r\n\r\n    /** Desired milliseconds between update calls. */\r\n    this.targetTickDelta = hertz ? (1 / Math.abs(hertz) * 1000) : 0;\r\n\r\n    /** Callbacks executed up to hertz rate */\r\n    this._callbacks = [/* { id: int, callback: Function} */]\r\n    /** Callbacks that have been marked for removal and need to be cleaned up  */\r\n    this._disposedCallbacks = [/* int */];\r\n    /** Last time this tick executed callbacks */\r\n    this._lastExecutionTime = performance.now()\r\n    /** Time interval was paused */\r\n    this._pauseTime = 0\r\n\r\n    if (Array.isArray(callback)) {\r\n      callback.forEach((fn => this.addCallback(fn)).bind(this))\r\n    } else {\r\n      this.addCallback(callback)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds callback to tick event and returns GUID for the tick event.\r\n   *\r\n   * @param {function} callback - Executes every target hertz interval.\r\n   *\r\n   * @returns {int} ID of the callback.\r\n   */\r\n  addCallback(callback) {\r\n    // Find unused callback ID.\r\n    let id = (this._callbacks.length + 1) * Math.floor(Math.random() * 1000)\r\n    while (this._callbacks.includes(evt => evt.id === id)) {\r\n      id++\r\n    }\r\n    this._callbacks.push({id, fn: callback})\r\n    return id\r\n  }\r\n\r\n  /**\r\n   * Helper for adding multiple callbacks. To get back the ID of the callback, use addCallback().\r\n   *\r\n   * @param {function} callback - Executes every target hertz interval.\r\n   * @param  {...function} additionalCallbacks\r\n   */\r\n  addCallbacks(callback, ...callbacks) {\r\n    this.addCallback(callback)\r\n    if (callbacks.length != 0) this.addCallbacks(callbacks[0], ...callbacks.slice(1))\r\n  }\r\n\r\n  /**\r\n   * Removes callback from tick interval.\r\n   *\r\n   * Disposed callbacks are not called again and get cleaned on the next tick.\r\n   *\r\n   * @param {int} id ID returned from an `addCallback`\r\n   */\r\n  removeCallback(id) {\r\n    this._disposedCallbacks.push(id)\r\n  }\r\n\r\n  /**\r\n   * Handle time passed and execute callbacks if necessary\r\n   * @param {int} timeNow - Timestamp from a requestAnimationFrame callback\r\n   */\r\n  processTime(timeNow) {\r\n    // Cleanup disposed callbacks\r\n    this._callbacks = this._callbacks.filter(c => !this._disposedCallbacks.includes(c.id))\r\n    this._disposedCallbacks = [];\r\n\r\n    // This assumes we want to run constant time steps as fast as possible with constant manual deltas\r\n    if (_constantTimeStepOverride || _stepTicking) {\r\n      this._callbacks.forEach(callback => callback.fn(_constantTimeStepHertz, timeNow));\r\n      return;\r\n    }\r\n\r\n    // Process time difference\r\n    let delta = timeNow - this._lastExecutionTime;\r\n    if (delta >= this.targetTickDelta) {\r\n      this._callbacks.forEach(callback => callback.fn(delta, timeNow));\r\n      // Setting _lastExecutionTime simply to `timeNow` will cause the clock to drift.\r\n      // We need capture the spillover so we set back the time by `delta - this.targetTickDelta`.\r\n      if (this.targetTickDelta > 0) {\r\n        // If time does not get processed for a period longer than a hertz tick, the next tick\r\n        // will send a very large delta then wait a long time due to the large spillover, so we\r\n        // need to mod the difference by the hertz rate to get our next tick back in step.\r\n        delta = delta % this.targetTickDelta;\r\n      } else {\r\n        // Skip this if hertz is zero since `% 0` is NaN.\r\n        delta = 0;\r\n      }\r\n      this._lastExecutionTime = timeNow - 2 * delta;\r\n    }\r\n  }\r\n\r\n  /** If this tick interval has not be paused already, notes the pause time. */\r\n  pauseTime(timeNow) {\r\n    if (this._pauseTime != null) return\r\n\r\n    this._pauseTime = timeNow\r\n  }\r\n\r\n  /** If this tick interval was paused, moves up the last execution time since halt time from `pauseTime()`. */\r\n  startTime(timeNow) {\r\n    _stepTicking = false;\r\n    if (this._pauseTime == null) {\r\n      this._lastExecutionTime = timeNow;\r\n    } else {\r\n      this._lastExecutionTime += timeNow - this._pauseTime\r\n      this._pauseTime = null\r\n    }\r\n  }\r\n}\r\n\r\nlet _animationFrameId;\r\n/** @type {[TickInterval]} */\r\nlet _tickIntervals = [];\r\nlet _disposedIntervals = [/* int */];\r\n\r\n/** Internal: Handle requestAnimFrame callback. */\r\nfunction update(timeNow) {\r\n  // Cleanup old intervals\r\n  _tickIntervals = _tickIntervals.filter(t => !_disposedIntervals.includes(t.label))\r\n  _disposedIntervals = []\r\n\r\n  _tickIntervals.forEach(tickInterval => tickInterval.processTime(timeNow))\r\n  if (running()) _animationFrameId = window.requestAnimationFrame(update)\r\n}\r\n\r\n/**\r\n * Creates a tick interval with the given unique label\r\n *\r\n * @param {string} label - Unique label to identify tick interval.\r\n * @param {function(delta, timestamp)|[function(delta, timestamp)]} callback - Callback(s) to initialize interval with. Can be a singular function or array of functions\r\n * @param {int} hertz - Target executions per second. Default is zero for highest possible tick rate.\r\n */\r\nfunction addInterval(label, callback = [], hertz = 0) {\r\n  if (_tickIntervals.some(tickInterval => tickInterval.label == label))\r\n    throw `Interval label \"${label}\" is already in use.`\r\n\r\n  _tickIntervals.push(new TickInterval(label, callback, hertz));\r\n}\r\n\r\nfunction removeInterval(label) {\r\n  _disposedIntervals.push(label)\r\n}\r\n\r\n/**\r\n * Adds callback to tick interval by label and returns GUID for the tick event.\r\n *\r\n * @param {function} callback - To add to interval callbacks.\r\n *\r\n * @returns {int} ID of the callback.\r\n */\r\nfunction addCallback(label, callback) {\r\n  let tickInterval = _tickIntervals.find(tickInterval => tickInterval.label == label)\r\n  if (tickInterval === undefined) {\r\n    throw `Interval label \"${label}\" does not exist.`\r\n  }\r\n\r\n  return tickInterval.addCallback(callback);\r\n}\r\n\r\n/**\r\n * Removes callback from tick interval by label.\r\n *\r\n * Disposed callbacks are not called again and get cleaned on the next tick.\r\n *\r\n * @param {int} id ID returned from an `addCallback`\r\n */\r\nfunction removeCallback(label, id) {\r\n  let tickInterval = _tickIntervals.find(tickInterval => tickInterval.label == label)\r\n  if (tickInterval === undefined) {\r\n    throw `Interval label \"${label}\" does not exist.`\r\n  }\r\n\r\n  tickInterval.removeCallback(id)\r\n}\r\n\r\n/** Get tick interval running state. */\r\nconst running = () => (_animationFrameId !== undefined)\r\n\r\n/** Start tick clock with given interval callbacks. */\r\nfunction start() {\r\n  if (running()) return\r\n\r\n  // Initialize timestamps - or resume if it was paused\r\n  let timeNow = performance.now()\r\n  _tickIntervals.forEach(tickInterval => tickInterval.startTime(timeNow))\r\n\r\n  _animationFrameId = window.requestAnimationFrame(update)\r\n}\r\n\r\n/** @deprecated TickClock.start() now handles paused clocks. */\r\nconst resume = start;\r\n\r\n/** Pause clock ticks. Cancel currently dispatched frame request. */\r\nfunction stop() {\r\n  if (!running()) return\r\n  window.cancelAnimationFrame(_animationFrameId)\r\n  _animationFrameId = undefined\r\n\r\n  // Recover tick intervals in progress\r\n  let timeNow = performance.now()\r\n  _tickIntervals.forEach(tickInterval => tickInterval.pauseTime(timeNow))\r\n}\r\n\r\n/** Stop and remove all tick intervals from clock. */\r\nasync function flush() {\r\n  _tickIntervals = []\r\n  stop()\r\n}\r\n\r\n// TODO test methods:\r\n\r\n/** Executes a single tick step without starting engine steps. Useful for testing or\r\n * piping a render intervals to output. */\r\nfunction stepTick() {\r\n  if (running()) stop()\r\n  _stepTicking = true;\r\n  window.requestAnimationFrame(update)\r\n}\r\n\r\n/**\r\n * Returns a promise which is resolved after the given number\r\n * of engine ticks pass.\r\n *\r\n * Example usage:\r\n *  `Engine.waitTicks(100).then(() => console.log(\"Finished 100.\"))`\r\n * @param {integer} ticks\r\n */\r\n function waitTicks(ticks) {\r\n   return new Promise((resolve) => {\r\n    let intervalLabel = `waitTick_${ticks}_${Math.random()}`;\r\n    let tickCount = ticks\r\n    let countTick = () => {\r\n      tickCount--\r\n      if (tickCount <= 0) {\r\n        removeInterval(intervalLabel)\r\n        return resolve()\r\n      }\r\n    }\r\n    addInterval(intervalLabel, countTick)\r\n  })\r\n}\r\n\n\n//# sourceURL=webpack://js-2d-pathing/./node_modules/@harxer/engine-2d/core/TickClock.js?");

/***/ }),

/***/ "./node_modules/@harxer/engine-2d/core/World.js":
/*!******************************************************!*\
  !*** ./node_modules/@harxer/engine-2d/core/World.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addTickClockInterval: () => (/* binding */ addTickClockInterval),\n/* harmony export */   cameraOffset: () => (/* binding */ cameraOffset),\n/* harmony export */   cameraTargetCoordinate: () => (/* binding */ cameraTargetCoordinate),\n/* harmony export */   entityAdd: () => (/* binding */ entityAdd),\n/* harmony export */   globalDebug: () => (/* binding */ globalDebug),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   setGlobalDebug: () => (/* binding */ setGlobalDebug),\n/* harmony export */   viewHeight: () => (/* binding */ viewHeight),\n/* harmony export */   viewWidth: () => (/* binding */ viewWidth),\n/* harmony export */   viewX: () => (/* binding */ viewX),\n/* harmony export */   viewY: () => (/* binding */ viewY)\n/* harmony export */ });\n/* harmony import */ var _TickClock_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TickClock.js */ \"./node_modules/@harxer/engine-2d/core/TickClock.js\");\n/* harmony import */ var _Input_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Input.js */ \"./node_modules/@harxer/engine-2d/core/Input.js\");\n/**\r\n * Provides a user-manipulated 2D space rendered to an HTML Canvas element.\r\n *\r\n * Provides a framework for a player, input, and camera backed by an TickClock module.\r\n * Render result is output to an HTML canvas element. Sets up key and mouse interactions\r\n * on the canvas element.\r\n *\r\n * Goal of World.js:\r\n * - World keeps references to abstract renderable entities. Calls each entities abstract functions.\r\n * - Render, zoom, and transform its HTML Canvas context.\r\n * - Attach user input to HTML Canvas and track input.\r\n *\r\n * @author Harrison Balogh\r\n */\r\n\r\n\r\n\r\n\r\n/** Controls console logging throughout package. */\r\nlet globalDebug = false;\r\n/** Override global console logging throughout package. @param {boolean} value  */\r\nfunction setGlobalDebug(value) {\r\n  globalDebug = value;\r\n}\r\n\r\nlet _htmlCanvasElement;\r\nlet _renderContext;\r\nlet _canvasFlush = true\r\nlet _view = {\r\n  width: 800,\r\n  height: 600,\r\n  x: 0,\r\n  y: 0\r\n}\r\nlet _entities = []\r\n\r\n/** Add entity to list. Returns newly added entity */\r\nfunction entityAdd(entity) {\r\n  _entities.push(entity)\r\n  return entity\r\n}\r\n\r\nconst viewX = () => _view.x\r\nconst viewY = () => _view.y\r\nconst viewWidth = () => _view.width\r\nconst viewHeight = () => _view.height\r\n\r\n/**\r\n * Center view on provided coordinates.\r\n * @param {int} x - Center view on x value\r\n * @param {int} y - Center view on y value\r\n * @TODO Add acceleration.\r\n * @usage World.addTickEvent(_ => World.cameraTargetCoordinate(player.pos.x, player.pos.y)) // Follow player\r\n */\r\nfunction cameraTargetCoordinate(x, y) {\r\n  let xMod = (x - _view.width / 2) - _view.x\r\n  let yMod = (y - _view.height / 2) - _view.y\r\n  _renderContext.translate(-xMod, -yMod)\r\n  _view.x = x - _view.width / 2\r\n  _view.y = y - _view.height / 2\r\n}\r\n\r\n/**\r\n * Offset view by provided values\r\n * @param {int} x - Offset view by x value\r\n * @param {int} y - Offset view by y value\r\n * @usage World.addTickEvent(_ => World.cameraOffset(1, 0)) // Constant right panning.\r\n */\r\nfunction cameraOffset(x, y) {\r\n  _renderContext.translate(x, y)\r\n  _view.x -= x\r\n  _view.y -= y\r\n}\r\n\r\n/**\r\n * Add interval to world tick clock.\r\n * @param {Function} callback\r\n */\r\nfunction addTickClockInterval(label, hertz, callback) {\r\n  _TickClock_js__WEBPACK_IMPORTED_MODULE_0__.addInterval(label, hertz, callback);\r\n}\r\n\r\n/** Dispose entities flagged for removal */\r\nfunction entityDispose() {\r\n  for (let i = 0; i < _entities.length; i++) {\r\n    if (_entities[i].removed) {\r\n      _entities.splice(i, 1)\r\n      i--\r\n    }\r\n  }\r\n}\r\n\r\n/** Populate entity collisions array */\r\nfunction entityCheckCollisions() {\r\n  _entities.forEach(entity => entity.collisions = [])\r\n\r\n  for (let e = 0; e < _entities.length - 1; e++) {\r\n    let entity = _entities[e]\r\n    if (entity.colliderType === undefined) continue\r\n\r\n    for (let p = e + 1; p < _entities.length; p++) {\r\n      let peer = _entities[p]\r\n      if (peer.colliderType === undefined || !(COLLIDER_MASK[entity.colliderType] & peer.colliderType)) continue\r\n        let xDist = Math.pow(peer.position.x - entity.position.x, 2)\r\n        let yDist = Math.pow(peer.position.y - entity.position.y, 2)\r\n        if (xDist + yDist < Math.pow(peer.size + entity.size, 2)) {\r\n          entity.collisions.push(peer)\r\n          peer.collisions.push(entity)\r\n        }\r\n    }\r\n  }\r\n}\r\n\r\n/** Update each entity */\r\nfunction entityUpdates(delta, timestamp) {\r\n  _entities.forEach(entity => entity.update(delta, timestamp))\r\n}\r\n\r\n/** Render each entity */\r\nfunction entityRender(context) {\r\n  _entities.forEach(entity => entity.render(context))\r\n}\r\n\r\n/** Internal: Call entity update handlers and dispose old entities */\r\nfunction updateTick(delta, timestamp) {\r\n  // entityCheckCollisions()\r\n  entityDispose()\r\n\r\n  // Handle player input\r\n  // _player.handleInput(delta, InputReader.playerInputVectorUpdate(timestamp))\r\n  // if (InputReader.isMouseDown() && !InputReader.isMouseWithShift()) {\r\n      // _player.spit()\r\n  // }\r\n\r\n  entityUpdates(delta, timestamp)\r\n}\r\n\r\n/** Internal: Call entity render handlers and flushes previous frame.  */\r\nfunction renderTick() {\r\n  // Clear previous draw frame\r\n  if (_canvasFlush) _renderContext.clearRect(_view.x, _view.y, _view.width, _view.height)\r\n  // Draw entities\r\n  entityRender(_renderContext)\r\n}\r\n\r\n/** Internal: Synchronizes canvas width with HTML element size  */\r\nfunction syncCanvasSize() {\r\n  // Canvas transforms cleared on setting its height or width. Preserve here\r\n  let transform = _renderContext.getTransform()\r\n\r\n  // Keep canvas render size matching style size\r\n  _htmlCanvasElement.width = _htmlCanvasElement.offsetWidth\r\n  _htmlCanvasElement.height = _htmlCanvasElement.offsetHeight\r\n\r\n  // Apply preserved context transformations\r\n  _renderContext.setTransform(transform)\r\n\r\n  // World viewport is kept at same size as canvas\r\n  _view.width = _htmlCanvasElement.offsetWidth\r\n  _view.height = _htmlCanvasElement.offsetHeight\r\n}\r\n\r\n/**\r\n * Attach a World module to an HTML canvas element selector to render result of\r\n * of simulation. Attaches mouse listeners to canvas for mouse interactions.\r\n *\r\n * @param canvas {Canvas} HTML Canvas element for scene render and mouse listener.\r\n */\r\nfunction init(htmlCanvasElement) {\r\n  // Init canvas context\r\n  _htmlCanvasElement = htmlCanvasElement\r\n  _renderContext = _htmlCanvasElement.getContext('2d')\r\n  syncCanvasSize()\r\n  window.addEventListener('resize', syncCanvasSize)\r\n\r\n  // Setup keyboard and mouse actions\r\n  _Input_js__WEBPACK_IMPORTED_MODULE_1__.InputInitializer.initMouseListener(_htmlCanvasElement)\r\n  _Input_js__WEBPACK_IMPORTED_MODULE_1__.InputInitializer.initKeyListener()\r\n  _Input_js__WEBPACK_IMPORTED_MODULE_1__.InputInitializer.initInputPlayerHandler()\r\n\r\n  // Setup tick clock\r\n  _TickClock_js__WEBPACK_IMPORTED_MODULE_0__.addInterval('update', updateTick, 0)\r\n  _TickClock_js__WEBPACK_IMPORTED_MODULE_0__.addInterval('render', renderTick, 60)\r\n  _TickClock_js__WEBPACK_IMPORTED_MODULE_0__.start()\r\n}\r\n\n\n//# sourceURL=webpack://js-2d-pathing/./node_modules/@harxer/engine-2d/core/World.js?");

/***/ }),

/***/ "./node_modules/@harxer/engine-2d/helpers/layout/GraphEdge.js":
/*!********************************************************************!*\
  !*** ./node_modules/@harxer/engine-2d/helpers/layout/GraphEdge.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GraphEdge)\n/* harmony export */ });\n/**\r\n * Wrapper for a HXGeometry Segment which can link to a peer edge lying on\r\n * itself in reverse direction. Retains reference to parent triangle in graph.\r\n */\r\nclass GraphEdge {\r\n  /**\r\n   * @param {GraphTriangle} parent\r\n   * @param {Segment} edge\r\n   * @param {GraphEdge} peer\r\n   */\r\n  constructor(parent, edge, peer = undefined) {\r\n    this._parent = parent;\r\n    this._edge = edge;\r\n    this._peer = peer;\r\n    // Object.freeze(this); // TODO - verify\r\n  }\r\n\r\n  // ------------------------ Properties\r\n\r\n  /** Graph triangle border edge. @returns {Segment} */\r\n  get edge() {\r\n    return this._edge;\r\n  }\r\n  set edge(_) { throw Error('Graph edge is immutable.') }\r\n\r\n  /**\r\n   * Graph triangle border edge's overlapping peer edge.\r\n   * @returns {GraphEdge?} Peer graph edge or undefined if no bordering triangle in graph.\r\n   */\r\n  get peer() {\r\n    return this._peer;\r\n  }\r\n  /** Sets peer GraphEdge to this structure. Also syncs peerEdge's `peer` to `this`. */\r\n  set peer(_) { throw Error('Graph edge peer is linked with `linkEdge(peer)`.') }\r\n\r\n  /** Graph edge's owning triangle. @returns {GraphTriangle} */\r\n  get parent() {\r\n    return this._parent;\r\n  }\r\n  set parent(_) { throw Error('Graph edge parent is immutable.') }\r\n\r\n  // ------------------------ Functions\r\n\r\n  linkEdge(peerEdge) {\r\n    this._peer = peerEdge;\r\n    peerEdge._peer = this;\r\n  }\r\n\r\n  /** Structure stringified for readability. @returns {string} \"(x,y) -> (x,y)\" or \"(x,y) plus <vector>\" */\r\n  logString() {\r\n    return \"// TODO\"\r\n  }\r\n\r\n  // --------------------- Static methods\r\n\r\n  // --------------------- Internal methods\r\n\r\n}\r\n\n\n//# sourceURL=webpack://js-2d-pathing/./node_modules/@harxer/engine-2d/helpers/layout/GraphEdge.js?");

/***/ }),

/***/ "./node_modules/@harxer/engine-2d/helpers/layout/GraphTriangle.js":
/*!************************************************************************!*\
  !*** ./node_modules/@harxer/engine-2d/helpers/layout/GraphTriangle.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GraphTriangle)\n/* harmony export */ });\n/* harmony import */ var _GraphEdge_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GraphEdge.js */ \"./node_modules/@harxer/engine-2d/helpers/layout/GraphEdge.js\");\n\r\n\r\n/**\r\n * Wrapper for graph polygon.\r\n * @property edges\r\n */\r\nclass GraphTriangle {\r\n  /**\r\n   * @param {Polygon} triangle\r\n   */\r\n  constructor(triangle) {\r\n    if (triangle === undefined || triangle.edges.length !== 3) {\r\n      throw Error(`Graph triangle poorly formed. Must be defined and 3-edged: ${triangle?.logString()}`)\r\n    }\r\n    this._triangle = triangle;\r\n    this._edges = triangle.edges.map(edge => new _GraphEdge_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this, edge));\r\n    this._area = undefined;\r\n  }\r\n\r\n  /** Graph triangle node. @returns {Polygon} */\r\n  get triangle() {\r\n    return this._triangle;\r\n  }\r\n  set triangle(_) { throw Error('Graph triangle is immutable.') }\r\n\r\n  /** Graph triangle graph edges. @returns {[GraphEdge]} */\r\n  get edges() {\r\n    return this._edges;\r\n  }\r\n  set edges(_) { throw Error('Graph edges cannot be set.') }\r\n\r\n  get area() {\r\n    if (this._area === undefined) {\r\n      // Sides of triangle\r\n      let a = this.triangle.edges[0].distance\r\n      let b = this.triangle.edges[1].distance\r\n      let c = this.triangle.edges[2].distance\r\n      // Semi perimeter\r\n      let s = (a + b + c) / 2\r\n      this._area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\r\n    }\r\n    return this._area;\r\n  }\r\n  set area(_) { throw Error('Graph triangle area cannot be set.') }\r\n\r\n  // ------------------------ Functions\r\n\r\n  /** Serializes structure to a string. @returns {string} */\r\n  logString() {\r\n    return '// TODO';\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://js-2d-pathing/./node_modules/@harxer/engine-2d/helpers/layout/GraphTriangle.js?");

/***/ }),

/***/ "./node_modules/@harxer/engine-2d/helpers/layout/Layout.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@harxer/engine-2d/helpers/layout/Layout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Layout)\n/* harmony export */ });\n/* harmony import */ var _Mesh_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Mesh.js */ \"./node_modules/@harxer/engine-2d/helpers/layout/Mesh.js\");\n/* harmony import */ var _harxer_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @harxer/geometry */ \"./node_modules/@harxer/geometry/lib/geometry.js\");\n/* harmony import */ var _Pathfinding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Pathfinding.js */ \"./node_modules/@harxer/engine-2d/helpers/layout/Pathfinding.js\");\n/* harmony import */ var _tools_LayoutManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tools/LayoutManager.js */ \"./node_modules/@harxer/engine-2d/helpers/layout/tools/LayoutManager.js\");\n/* harmony import */ var _core_World_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/World.js */ \"./node_modules/@harxer/engine-2d/core/World.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n/** Maintains reference to the root of nested mesh structure. object selection, insertion, and deletion. */\r\nclass Layout {\r\n  constructor() {\r\n    /**\r\n     * This defines the current triangulation space. If the layout is empty, this\r\n     * will be undefined. The first mesh to be added is the highest level mesh context.\r\n     * The holes of this mesh can then be selected as the current context - down the\r\n     * cascading tree of hole meshes.\r\n     * @type {Mesh}\r\n     */\r\n    this.meshContext = undefined;\r\n    /**\r\n     * Root-most mesh object present in layout. This object can be traversed for all other\r\n     * meshes present in the scene through the Mesh `holes` property.\r\n     * @type {Mesh}\r\n     */\r\n    this.rootMesh = undefined;\r\n  }\r\n\r\n  /** Creates a hole in the current mesh context out of the given vertices. Returns latest mesh addition. */\r\n  insertContextHole(vertices) {\r\n    let polygon = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_1__.Polygon(vertices);\r\n\r\n    // If scene is empty, need to define mesh root.\r\n    if (this.meshContext === undefined) {\r\n      if (polygon.counterclockwise) {\r\n        console.error('Root boundary must be CCW.')\r\n        return; // Root must be CCW\r\n      }\r\n      this.rootMesh = new _Mesh_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](polygon);\r\n      this.meshContext = this.rootMesh;\r\n      (0,_tools_LayoutManager_js__WEBPACK_IMPORTED_MODULE_3__.setLayoutPolygons)([polygon])\r\n      if (_core_World_js__WEBPACK_IMPORTED_MODULE_4__.globalDebug) console.log(`Creating root boundary.`, [polygon])\r\n      return this.meshContext;\r\n    }\r\n    if (_core_World_js__WEBPACK_IMPORTED_MODULE_4__.globalDebug) console.log(`Adding polygon.`, [polygon])\r\n    ;(0,_tools_LayoutManager_js__WEBPACK_IMPORTED_MODULE_3__.pushLayoutPolygon)(polygon);\r\n    return this.meshContext.applyHole(polygon);\r\n  }\r\n\r\n  contextSelection(p) {\r\n    if (this.meshContext === undefined) return;\r\n    let holeSelected = this.meshContext.holes.find(hole => !hole.bounds.containsPoint(p));\r\n\r\n    if (holeSelected) {\r\n      this.meshContext = holeSelected;\r\n      if (_core_World_js__WEBPACK_IMPORTED_MODULE_4__.globalDebug) console.log(`Selected hole`, [this.meshContext.bounds])\r\n    } else {\r\n      if (this.meshContext.bounds.containsPoint(p)) {\r\n        if (this.meshContext.parent !== undefined) {\r\n          this.meshContext = this.meshContext.parent;\r\n          if (_core_World_js__WEBPACK_IMPORTED_MODULE_4__.globalDebug) console.log(`Selected bounds`, [this.meshContext.bounds])\r\n        }\r\n      } else {\r\n        let graphTriangle = this.meshContext.triangulatedGraph.find(({triangle}) => triangle.containsPoint(p));\r\n        if (graphTriangle !== undefined) {\r\n          if (_core_World_js__WEBPACK_IMPORTED_MODULE_4__.globalDebug) console.log(`Graph triangle ${graphTriangle.triangle.console.logString()}`, [graphTriangle.triangle])\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete mesh if contains given point. Root mesh can be removed if highlighted outer clicked.\r\n   * @param {Point} p\r\n   * @returns {boolean} true if layout changed.\r\n   */\r\n  deleteMeshUnderPoint(p) {\r\n    if (this.meshContext === undefined) return false;\r\n    if (this.meshContext.removeHoleUnderPoint(p)) return true;\r\n\r\n    // TODO this console.logic probably shouldnt be provided by Layout.js\r\n    if (this.meshContext === this.rootMesh && this.rootMesh.bounds.containsPoint(p)) {\r\n      this.meshContext = undefined;\r\n      this.rootMesh = undefined;\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /** Runs pathfinding on the current mesh context. Route endpoints will be moved outside of blockers if internal. */\r\n  contextRoute(origin, destination, logged = true) {\r\n    origin = this.meshContext.bounds.closestPointOutsideFrom(origin)\r\n    destination = this.meshContext.bounds.closestPointOutsideFrom(destination)\r\n\r\n    // TODO - polygon.copy is REALLY slow. 90% of this function process time goes to copy calls\r\n    this.meshContext.holes.forEach(hole => {\r\n      let reverseHole = hole.bounds.copy.reverse();\r\n      origin = reverseHole.closestPointOutsideFrom(origin)\r\n      destination = reverseHole.closestPointOutsideFrom(destination)\r\n    })\r\n\r\n    return (0,_Pathfinding_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.meshContext.triangulatedGraph, origin, destination, logged);\r\n  }\r\n\r\n  /** Recursive JSON builder for layout meshes. */\r\n  serialized() {\r\n    if (this.rootMesh === undefined) return;\r\n\r\n    const _serializeNode = (node) => { return {\r\n      bounds: node.bounds.vertices.map(v => {return {x: v.x, y: v.y}}),\r\n      holes: node.holes.map(_serializeNode)\r\n    }}\r\n\r\n    return JSON.stringify([_serializeNode(this.rootMesh)]);\r\n  }\r\n\r\n  static fromJson(serializedLayoutString) {\r\n    let newLayout = new Layout();\r\n\r\n    // Parses a serialized (to JSON) layout string. Populates mesh context\r\n    const _processNode = (node, parent) => {\r\n      node.holes.forEach(hole => {\r\n        let polygon = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_1__.Polygon(hole.bounds).reverse();\r\n        (0,_tools_LayoutManager_js__WEBPACK_IMPORTED_MODULE_3__.pushLayoutPolygon)(polygon);\r\n        _processNode(hole, parent.applyHole(polygon));\r\n      })\r\n    }\r\n    let node = JSON.parse(serializedLayoutString)[0];\r\n    newLayout.meshContext = undefined; // Reset root\r\n    _processNode(node, newLayout.insertContextHole(node.bounds));\r\n\r\n    return newLayout;\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://js-2d-pathing/./node_modules/@harxer/engine-2d/helpers/layout/Layout.js?");

/***/ }),

/***/ "./node_modules/@harxer/engine-2d/helpers/layout/Mesh.js":
/*!***************************************************************!*\
  !*** ./node_modules/@harxer/engine-2d/helpers/layout/Mesh.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Mesh)\n/* harmony export */ });\n/* harmony import */ var _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @harxer/geometry */ \"./node_modules/@harxer/geometry/lib/geometry.js\");\n/* harmony import */ var _Triangulation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Triangulation.js */ \"./node_modules/@harxer/engine-2d/helpers/layout/Triangulation.js\");\n/* harmony import */ var _core_World_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/World.js */ \"./node_modules/@harxer/engine-2d/core/World.js\");\n/* harmony import */ var _GraphTriangle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GraphTriangle.js */ \"./node_modules/@harxer/engine-2d/helpers/layout/GraphTriangle.js\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * A connected set of triangles within a {Layout}. Can be the hole of a containing {Mesh} tracked\r\n * by the `parent` reference. Each hole of this Mesh can be another Mesh - creating a nested\r\n * structure. Retrieving the `triangulatedGraph` of this Mesh will get the degenerate connected\r\n * triangles interior to its `bounds` polygon while avoiding `holes` polygons.\r\n * @param {Polygon} polygon - Boundary polygon of this mesh.\r\n * @param {[Mesh]} holes - Any Mesh holes nested in this Mesh.\r\n * @param {Mesh} parent - Containing mesh that this mesh is a hole in.\r\n */\r\nclass Mesh {\r\n  constructor(polygon, holes = [], parent) {\r\n    /** Boundary polygon. @type {Polygon} */\r\n    this.bounds = polygon;\r\n    /** @type {[Mesh]} */\r\n    this.holes = holes;\r\n    /** @type {Mesh} */\r\n    this.parent = parent;\r\n\r\n    /** Set to undefined if needs new triangulation compute, else array. */\r\n    this._triangulatedGraph = undefined;\r\n    this._area = undefined;\r\n  }\r\n\r\n  /** Flag mesh for new triangulation compute on next graph array retrieval. */\r\n  needsTriangulation() {\r\n    this._triangulatedGraph = undefined;\r\n    this._area = undefined\r\n  }\r\n\r\n  /** @returns {[GraphTriangle]} */\r\n  get triangulatedGraph() {\r\n    if (this._triangulatedGraph === undefined) {\r\n      try {\r\n        this._triangulatedGraph = (0,_Triangulation_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\r\n          this.bounds,\r\n          this.holes.map(hole => hole.bounds.copy.reverse())\r\n        )\r\n      } catch(e) {\r\n        if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`No bridges. Error: ${e}`, e)\r\n        this._triangulatedGraph = [];\r\n      }\r\n    }\r\n    return this._triangulatedGraph;\r\n  }\r\n\r\n  get area() {\r\n    if (this._area === undefined) {\r\n      this._area = this.triangulatedGraph.reduce((sum, tri) => sum + tri.area, 0)\r\n    }\r\n    return this._area;\r\n  }\r\n\r\n  render(context) {\r\n    if (this.polygon !== undefined) context.strokeStyle = \"Red\";\r\n    context.fillStyle = \"rgba(200, 50, 50, 0.1)\"\r\n    if (this.polygon !== undefined && this.polygon.counterclockwise) context.strokeStyle = \"Blue\";\r\n    this.polygon.vertices.forEach(vertices => {\r\n      vertices.forEach((vertex, i) => {\r\n        if (i == 0) {\r\n          context.beginPath();\r\n          context.moveTo(vertex.x, vertex.y);\r\n        } else {\r\n          context.lineTo(vertex.x, vertex.y);\r\n        }\r\n      });\r\n      context.lineTo(vertices[0].x, vertices[0].y);\r\n      if (this.polygon === undefined || this.polygon.clockwise) context.fill();\r\n      context.stroke();\r\n    });\r\n  }\r\n\r\n  /** Returns latest mesh. This will be itself or the new hole. */\r\n  applyHole(polygon) {\r\n    let self = this;\r\n    // Check overlap\r\n    if (this.bounds.overlaps(polygon)) {\r\n      this.needsTriangulation();\r\n      // CCW polygon subtract from bounds, CW union\r\n      this.bounds = this.bounds.union(polygon);\r\n      if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`Union bounds`, [polygon, this.bounds])\r\n    } else if (polygon.counterclockwise && polygon.vertices.some(vertex => !self.bounds.containsPoint(vertex))) {\r\n      this.needsTriangulation();\r\n      // Internal contained polygons become holes\r\n      let newMesh;\r\n      let iOverlappedHole = this.holes.findIndex(hole => hole.bounds.overlaps(polygon));\r\n      if (iOverlappedHole !== -1) {\r\n        while (iOverlappedHole !== -1) {\r\n          let overlappedHole = this.holes.splice(iOverlappedHole, 1)[0].bounds.copy.reverse();\r\n          let overlayHole = newMesh ? newMesh.bounds.reverse() : polygon;\r\n          if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`Union hole ${overlappedHole.logString()}`, [overlappedHole])\r\n          if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`  ... onto ${overlayHole.logString()}`, [overlayHole])\r\n          let unionPolygon = overlappedHole.union(overlayHole).reverse();\r\n          newMesh = new Mesh(unionPolygon, overlappedHole.holes.concat(newMesh ? newMesh.holes : []), this)\r\n          if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`  ... new hole`, [newMesh.bounds])\r\n\r\n          iOverlappedHole = this.holes.findIndex(hole => hole.bounds.overlaps(unionPolygon));\r\n          if (iOverlappedHole === -1) {\r\n\r\n            // Remove holes swallowed by new hole\r\n            let iInternalHole = this.holes.findIndex(hole => !newMesh.bounds.contains(hole.bounds));\r\n            while (iInternalHole !== -1) {\r\n              if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`Removing smaller internal hole`, [this.holes.splice(iInternalHole, 1)])\r\n              iInternalHole = this.holes.findIndex(hole => !newMesh.bounds.contains(hole.bounds));\r\n            }\r\n\r\n            this.holes.push(newMesh)\r\n            if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`Adding union hole`, [newMesh.bounds])\r\n            return newMesh;\r\n          }\r\n        }\r\n      } else {\r\n        if (this.holes.some(hole => !hole.bounds.contains(polygon))) {\r\n          if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`Ignoring internal polygon.`, [polygon])\r\n          return this;\r\n        }\r\n        polygon = polygon.copy.reverse();\r\n        let newMesh = new Mesh(polygon, [], this);\r\n\r\n        // Remove holes swallowed by new hole\r\n        let iInternalHole = this.holes.findIndex(hole => !polygon.contains(hole.bounds));\r\n        while (iInternalHole !== -1) {\r\n          if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`Removing smaller internal hole`, [this.holes.splice(iInternalHole, 1)])\r\n          iInternalHole = this.holes.findIndex(hole => !polygon.contains(hole.bounds));\r\n        }\r\n\r\n        this.holes.push(newMesh);\r\n        if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`Adding non-overlapped hole`, [polygon])\r\n        return newMesh;\r\n      }\r\n    } else {\r\n      if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`Ignoring external polygon. CCW: ${polygon.counterclockwise}`, [polygon])\r\n    }\r\n    if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`Adding hole`, [polygon])\r\n    return this;\r\n    // Ignore non-overlapping counterclockwise polygons\r\n  }\r\n\r\n  /** Removes hole from mesh if hit by given point. @param {Point} p @returns true if removed a hole  */\r\n  removeHoleUnderPoint(p) {\r\n    let iHoleCollision = this.holes.findIndex(hole => !hole.bounds.containsPoint(p))\r\n    if (iHoleCollision > -1) {\r\n      this.holes.splice(iHoleCollision, 1);\r\n      this.needsTriangulation();\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** TODO - move out of this class.\r\n   * Get random triangle in triangulated graph weighted by area.\r\n   * @returns {GraphTriangle?}\r\n   */\r\n  getRandomGraphTriangle() {\r\n    if (!this.triangulatedGraph.length) return undefined;\r\n\r\n    const weightedPick = Math.random() * this.area;\r\n    let aggregateArea = 0;\r\n    for (let i = 0; i < this.triangulatedGraph.length; i++) {\r\n      aggregateArea += this.triangulatedGraph[i].area;\r\n      if (weightedPick < aggregateArea) {\r\n        return this.triangulatedGraph[i];\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** TODO - move out of this class.\r\n   * Get random point within mesh boundary (avoiding holes).\r\n   * @returns {{point: Point, graphTriangle: GraphTriangle}} Object with random point and graphTriangle\r\n   * it's located inside.\r\n   */\r\n  getRandomPoint() {\r\n    let randomGraphTriangle = this.getRandomGraphTriangle();\r\n    if (randomGraphTriangle === undefined) return {};\r\n\r\n    // Random point in parallelogram, generates points in desired triangle and reflected version of triangle\r\n    let randomA = Math.random();\r\n    let randomB = Math.random();\r\n    // Test if point is in first-half of triangle forming parallelogram (tri.containsPoint(randomPoint)))\r\n    if (randomA + randomB > 1) {\r\n      // Rotate or twice-reflect point selected in second-half of parallelogram into first triangle.\r\n      // This is the same as inverting the modifiers before applying to side vectors\r\n      randomA = 1 - randomA;\r\n      randomB = 1 - randomB;\r\n    }\r\n\r\n    let tri = randomGraphTriangle.triangle;\r\n    let vA = _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Vector.fromSegment(tri.vertices[0], tri.vertices[1]).multiplyBy(randomA)\r\n    let vB = _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Vector.fromSegment(tri.vertices[0], tri.vertices[2]).multiplyBy(randomB)\r\n    let randomPoint = tri.vertices[0].copy.add(vA.add(vB));\r\n    return {point: randomPoint, graphTriangle: randomGraphTriangle};\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://js-2d-pathing/./node_modules/@harxer/engine-2d/helpers/layout/Mesh.js?");

/***/ }),

/***/ "./node_modules/@harxer/engine-2d/helpers/layout/Pathfinding.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@harxer/engine-2d/helpers/layout/Pathfinding.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ route)\n/* harmony export */ });\n/* harmony import */ var _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @harxer/geometry */ \"./node_modules/@harxer/geometry/lib/geometry.js\");\n/* harmony import */ var _GraphEdge_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GraphEdge.js */ \"./node_modules/@harxer/engine-2d/helpers/layout/GraphEdge.js\");\n/* harmony import */ var _GraphTriangle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GraphTriangle.js */ \"./node_modules/@harxer/engine-2d/helpers/layout/GraphTriangle.js\");\n/* harmony import */ var _core_World_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/World.js */ \"./node_modules/@harxer/engine-2d/core/World.js\");\n\r\n\r\n\r\n\r\n\r\n/** Graph traversal node wrapping a GraphTriangle node. */\r\nclass PathNode {\r\n  constructor(graphTriangle) {\r\n    /** @type {Point} frontier - point towards destination */\r\n    this.frontier = undefined;\r\n    /** @type {GraphEdge} from - entry edge from previous polygon */\r\n    this.from = undefined;\r\n    /** @type {Number} cost - pathfinding heuristic value to reach this triangle */\r\n    this.cost = undefined;\r\n    /** @type {Number} priority - pathfinding queue pop modifier */\r\n    this.priority = undefined;\r\n    /** @type {GraphTriangle} graphTriangle - triangle and edge details */\r\n    this.graphTriangle = graphTriangle;\r\n  }\r\n}\r\n\r\n/**\r\n * Apply A* pathfinding to graph.\r\n * @param {[GraphTriangle]} graph Edge joined array of polygons. Polygon edges hold references to neighboring polygons.\r\n * @param {Point} origin Start position\r\n * @param {Point} destination Goal position\r\n * @returns {[{point: Point, polygon: Polygon}]} shortest line segments through route\r\n */\r\nfunction route(graph, origin, destination) {\r\n  if (_core_World_js__WEBPACK_IMPORTED_MODULE_3__.globalDebug) console.log(`Routing ${origin.logString()} to ${destination.logString()}`, [origin, destination], true)\r\n  let iOrigin = undefined\r\n  let iDestination = undefined\r\n\r\n  // Find origin and destination polygons // TODO Can optimize. Sub-quadrants for faster start/destination resolution. Currently O(n)\r\n  for (let i = 0; i < graph.length; i++) {\r\n    let polygon = graph[i].triangle;\r\n    if (iOrigin === undefined && polygon.containsPoint(origin)) iOrigin = i\r\n    if (iDestination === undefined && polygon.containsPoint(destination)) iDestination = i\r\n    if (iOrigin !== undefined && iDestination !== undefined) break\r\n  }\r\n  if (iOrigin === undefined || iDestination === undefined) return {};\r\n\r\n  let nodes = graph.map(graphTriangle => new PathNode(graphTriangle));\r\n\r\n  const pathfinder = {\r\n\r\n    /** @type {[PathNode]} */\r\n    priorityStack: [],\r\n\r\n    get length() { return this.priorityStack.length },\r\n\r\n    /** Push a PathNode to priority stack. Optionally set priority on node. */\r\n    push(node, priority = undefined) {\r\n      if (this.priorityStack.indexOf(node) != -1) return // Skip if already in stack\r\n      if (priority !== undefined) node.priority = priority; // Update priority if needed\r\n      this.priorityStack.push(node)\r\n    },\r\n\r\n    /** TODO Optimize. Make queue - insert in priority rank. @returns {PathNode} */\r\n    pop() {\r\n      // Retrieve highest priority (lowest value) node\r\n      let { iNode } = this.priorityStack.reduce((lowest, { priority }, iNode) => {\r\n        if (priority === undefined) throw Error(\"Bad pathfinding logic. Node missing priority.\");\r\n        if (priority < lowest.priority) return { priority, iNode };\r\n        return lowest;\r\n      }, {priority: Infinity})\r\n      // Pop from stack\r\n      let node = this.priorityStack.splice(iNode, 1)[0];\r\n      node.priority = undefined;\r\n      return node;\r\n    }\r\n  }\r\n\r\n  // Initialize origin node\r\n  nodes[iOrigin].cost = 0\r\n  nodes[iOrigin].frontier = origin\r\n  pathfinder.push(nodes[iOrigin], 0)\r\n\r\n  let reachedDestination = false;\r\n\r\n  // Populate `from` on each node with cheapest route to destination graph triangle node\r\n  while (pathfinder.length != 0) {\r\n    let current = pathfinder.pop();\r\n\r\n    if (current === nodes[iDestination]) {\r\n      reachedDestination = true;\r\n      break;\r\n    }\r\n\r\n    if (_core_World_js__WEBPACK_IMPORTED_MODULE_3__.globalDebug) console.log(`    Processing node.`, [current.graphTriangle.triangle])\r\n\r\n    // Compute cost of crossing each shared graph edge into neighboring triangle\r\n    current.graphTriangle.edges.forEach(graphEdge => {\r\n      if (graphEdge.peer === undefined) return\r\n\r\n      let neighbor = nodes[graph.indexOf(graphEdge.peer.parent)]\r\n      let frontier = graphEdge.edge.closestPointToPoint(current.frontier)\r\n      let cost = current.cost + _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment.distance(current.frontier, frontier) // TODO: edge cost is always 0, can change this to distanceSqrd?\r\n      // testLine(current.frontier, frontier)\r\n      if (_core_World_js__WEBPACK_IMPORTED_MODULE_3__.globalDebug) console.log(`        Edge cost ${cost}`, [current.frontier, frontier, graphEdge.edge]);\r\n\r\n      // Found cheaper route to node, update cost and frontier\r\n      if (neighbor.cost === undefined || cost < neighbor.cost) {\r\n        neighbor.cost = cost\r\n        neighbor.frontier = frontier\r\n        neighbor.from = graphEdge.peer;\r\n        let priority = cost + _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment.distance(frontier, destination) // Route heuristic\r\n        if (priority === undefined) throw Error(\"Pathfinding error. Failed to calculate priority.\");\r\n        pathfinder.push(neighbor, priority);\r\n      }\r\n    })\r\n  }\r\n\r\n  if (!reachedDestination) {\r\n    console.error('Could not find path to destination.')\r\n    if (_core_World_js__WEBPACK_IMPORTED_MODULE_3__.globalDebug) console.log('Could not find path to destination.')\r\n  }\r\n\r\n  // Join path node `from` linked graph edges to form route\r\n  if (_core_World_js__WEBPACK_IMPORTED_MODULE_3__.globalDebug) console.log(`Traversing route links.`);\r\n  let current = nodes[iDestination]\r\n  /** Graph triangle graph edges crossed to reach destination. @type {[GraphEdge]} */\r\n  let graphEdgeCrossings = [];\r\n  while (current.from !== undefined) {\r\n    graphEdgeCrossings.push(current.from.peer)\r\n    if (_core_World_js__WEBPACK_IMPORTED_MODULE_3__.globalDebug) console.log(`    Processing node.`, [nodes[graph.indexOf(current.from.peer.parent)].graphTriangle.triangle]);\r\n    current = nodes[graph.indexOf(current.from.peer.parent)]; // TODO - indexOf can be replaced with `from` tracking the node index\r\n  }\r\n  return {path: createShortestPath(graphEdgeCrossings.reverse(), origin, destination), graphEdgeCrossings};\r\n}\r\n\r\n// ======== INTERNAL Helpers =========\r\n\r\n/**\r\n * Creates the shortest line through the connected route passed in\r\n * @param {[{polygon: Polygon, edge: Segment}]} route ordered array of hash with Polygon and edge connection to traverse\r\n * @param {Point} start starting position\r\n * @param {Point} finish goal position\r\n * @returns {[{point: Point, polygon: Polygon}]} shortest line segments through route\r\n */\r\nfunction createPath(route, start, finish) {\r\n  if (route.length == 1) return [start, finish]\r\n  let path = [{point: start, polygon: route[0]}]\r\n  // if (globalDebug) console.log(`Starting path from ${start.logString()}`, [start])\r\n\r\n  let frontierPath = start\r\n  for (let i = 1; i < route.length; i++) {\r\n    let frontierRoute = route[i];\r\n    let nextPoint = frontierRoute.polygon.containsPoint(finish) ? finish : frontierRoute.polygon.circumcenter\r\n    let trace = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(frontierPath, nextPoint)\r\n\r\n    // if (globalDebug) console.log(`  Tracing ${trace.logString()}`, [trace])\r\n\r\n    if (frontierRoute.edge.intersects(trace)) continue\r\n\r\n    // if (globalDebug) console.log(`    Failed ${trace.logString()}`, [frontierRoute.edge, trace])\r\n\r\n    let aEndpointDistSqrd = _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment.distanceSqrd(nextPoint, frontierRoute.edge.a)\r\n    let bEndpointDistSqrd = _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment.distanceSqrd(nextPoint, frontierRoute.edge.b)\r\n\r\n    frontierPath = aEndpointDistSqrd < bEndpointDistSqrd ? frontierRoute.edge.a : frontierRoute.edge.b\r\n    path.push({point: frontierPath, polygon: frontierRoute.polygon})\r\n  }\r\n\r\n  path.push({point: finish, polygon: route[route.length - 1].polygon})\r\n  return path\r\n}\r\n\r\n/**\r\n * Funnel algorithm.\r\n * Implementation described here: The Funnel Algorithm Explained\r\n * https://medium.com/@reza.teshnizi/the-funnel-algorithm-explained-visually-41e374172d2d\r\n */\r\nfunction createShortestPath(graphEdgeCrossings, start, finish) {\r\n  if (_core_World_js__WEBPACK_IMPORTED_MODULE_3__.globalDebug) console.log(`Creating shortest path.`);\r\n\r\n  let tail = [start] // {[Point]}\r\n  let apex = () => tail[tail.length - 1] // latest tail point\r\n  let left = [] // {[Point]}\r\n  let right = [] // {[Point]}\r\n  let boundaryIncludes = (boundary, point) => boundary.some(p => p.equals(point));\r\n  if (graphEdgeCrossings.length === 0) return tail.concat(finish)\r\n\r\n  let COUNTERR = 0\r\n  routeEdges: for (let i = 0; i < graphEdgeCrossings.length; i++) {\r\n    if (COUNTERR > 10) {\r\n      // if (globalDebug) console.log(\"Break 2\")\r\n      return\r\n    }\r\n    let edge = graphEdgeCrossings[i].edge\r\n    let polygonCenter = graphEdgeCrossings[i].parent.triangle.circumcenter\r\n    let exitSegment = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(polygonCenter, edge.midpoint())\r\n    if (_core_World_js__WEBPACK_IMPORTED_MODULE_3__.globalDebug) console.log(`    Crossing ${edge.logString()}`, [exitSegment, edge])\r\n\r\n    let lPoint, rPoint;\r\n    // Check crossing-edge endpoint boundary-side\r\n    let logStringL = '', logStringR = '';\r\n    if (exitSegment.directionTo(edge.a) > 0) {\r\n      lPoint = edge.a\r\n      rPoint = edge.b\r\n      logStringL = `    A is left. ${edge.a.logString()}`\r\n      logStringR = `    B is right. ${edge.b.logString()}`\r\n    } else {\r\n      lPoint = edge.b\r\n      rPoint = edge.a\r\n      logStringL = `    B is left. ${edge.b.logString()}`\r\n      logStringR = `    A is right. ${edge.a.logString()}`\r\n    }\r\n\r\n    // Left boundary checks\r\n    // if (globalDebug) console.log(logStringL, [exitSegment, edge.b])\r\n    if (left.length == 0) {\r\n      if (apex().equals(lPoint)) {\r\n        // if (globalDebug) console.log(`     Apex is left point. Skip ${lPoint.logString()}`, [...tail])\r\n      } else {\r\n        // if (globalDebug) console.log(`     First point L. Push: ${lPoint.logString()}`, [...tail, lPoint])\r\n        left.push(lPoint)\r\n      }\r\n    } else {\r\n      let COUNTERR2 = 0\r\n      if (!boundaryIncludes(left, lPoint)) {\r\n        if (COUNTERR2 > 20) {\r\n          // if (globalDebug) console.log(\"Break 3\")\r\n          return\r\n        }\r\n        // Check leftBound for funnel expansion, tighter bounds, or common vertex\r\n        let lPrev = apex()\r\n        let leftBoundaries = left.length\r\n        for (let l = 0; l < leftBoundaries; l++) {\r\n          let lEdge = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(lPrev, left[l])\r\n          // if (globalDebug) console.log(`     Check L ${lEdge.logString()}`, [lEdge, lPoint])\r\n\r\n          if (lEdge.directionTo(lPoint) < 0) { // Right side of left boundary segment\r\n\r\n            // Check right boundary\r\n            let onLeftofRightBoundary = true\r\n            if (l == 0) { // If checking first right boundary segment\r\n              for (let r = 0; r < right.length; r++) {\r\n                let rEdge = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(apex(), right[r])\r\n                // if (globalDebug) console.log(`      Check R ${rEdge.logString()}`, [rEdge, lPoint])\r\n\r\n                if (rEdge.directionTo(lPoint) < 0) { // Right side of right boundary segment\r\n                  // Common vertices (3)\r\n                  tail.push(...right.splice(0, 1))\r\n                  // if (globalDebug) console.log(`      Common vertex. ${apex().logString()} (left: ${left.length}) (right: ${right.length})`, [...tail])\r\n                  r--;\r\n                  onLeftofRightBoundary = false;\r\n                } else { // Left side of right boundary segment\r\n                  break; // Stop common vertex check on right\r\n                }\r\n              }\r\n            }\r\n\r\n            if (onLeftofRightBoundary) { // Left side of right boundary segment\r\n              // Tighter boundary (1)\r\n              left = left.slice(0, l) // Remove wider bounds\r\n              left.push(lPoint)\r\n              // if (globalDebug) console.log(`      Tighter bound L. ${lEdge.b.logString()} to ${lPoint.logString()} (left: ${left.length})`, [apex(), ...left])\r\n            } else {\r\n              left = [lPoint] // Move up left\r\n              continue routeEdges; // Skip the right boundary check\r\n            }\r\n            break // If right of left segment boundary, ignore rest of left boundary\r\n\r\n          } else if (l == leftBoundaries - 1) { // Left side of left boundary segment\r\n            // Expand funnel (2) if last bound checked\r\n            left.push(lPoint)\r\n            // if (globalDebug) console.log(`      Expand funnel L. ${lPoint.logString()} (left ${left.length})`, [...tail, ...left])\r\n          }\r\n\r\n          lPrev = left[l];\r\n        }\r\n      }\r\n      // else {\r\n        // if (globalDebug) console.log(`     Left includes ${lPoint.logString()}`, [...left])\r\n      // }\r\n    }\r\n\r\n\r\n    // Right boundary checks\r\n    // if (globalDebug) console.log(logStringR, [exitSegment, edge.a])\r\n    if (right.length == 0) {\r\n      if (apex().equals(rPoint)) {\r\n        // if (globalDebug) console.log(`     Apex is right point. Skip ${rPoint.logString()}`, [...tail])\r\n      } else {\r\n        // if (globalDebug) console.log(`     First point R. Push: ${rPoint.logString()}`, [...tail, rPoint])\r\n        right.push(rPoint)\r\n      }\r\n    } else {\r\n      let COUNTERR3 = 0\r\n      if (!boundaryIncludes(right, rPoint)) {\r\n        if (COUNTERR3 > 20) {\r\n          // if (globalDebug) console.log(\"Break 4\")\r\n          return\r\n        }\r\n        // Check rightBound for funnel expansion, tighter bounds, or common vertex\r\n        let rPrev = apex()\r\n        let rightBoundaries = right.length\r\n        for (let r = 0; r < rightBoundaries; r++) {\r\n          let rEdge = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(rPrev, right[r])\r\n          // if (globalDebug) console.log(`     Check R ${rEdge.logString()}`, [rEdge, rPoint])\r\n\r\n          if (rEdge.directionTo(rPoint) > 0) { // Left side of right boundary segment\r\n\r\n            // Check left boundary\r\n            let onRightOfLeftBoundary = true\r\n            if (r == 0) { // If checking first right boundary segment\r\n              for (let l = 0; l < left.length; l++) {\r\n                let lEdge = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(apex(), left[l])\r\n                // if (globalDebug) console.log(`      Check L ${lEdge.logString()}`, [lEdge, rPoint])\r\n\r\n                if (lEdge.directionTo(rPoint) > 0) { // Left side of left boundary segment\r\n                  // Common vertices (3)\r\n                  tail.push(...left.splice(0, 1))\r\n                  // if (globalDebug) console.log(`      Common vertex. ${apex().logString()} (left: ${left.length}) (right: ${right.length})`, [...tail])\r\n                  l--;\r\n                  onRightOfLeftBoundary = false;\r\n                } else { // Right side of left boundary segment\r\n                  break; // Stop common vertex check on left\r\n                }\r\n              }\r\n            }\r\n\r\n            if (onRightOfLeftBoundary) { // Right side of left boundary segment\r\n              // Tighter boundary (1)\r\n              right = right.slice(0, r) // Remove wider bounds\r\n              right.push(rPoint)\r\n              // if (globalDebug) console.log(`      Tighter bound R. ${rEdge.b.logString()} to ${rPoint.logString()} (right: ${right.length})`, [apex(), ...right])\r\n            } else {\r\n              right = [rPoint] // Move up right\r\n            }\r\n            break // If left of right segment boundary, ignore rest of right boundary\r\n\r\n          } else if (r == rightBoundaries - 1) { // Right side of right boundary segment\r\n            // Expand funnel (2) if last right bound checked\r\n            right.push(rPoint)\r\n            // if (globalDebug) console.log(`      Expand funnel R. ${rPoint.logString()} (right: ${right.length})`, [...tail, ...right])\r\n          }\r\n\r\n          rPrev = right[r]\r\n        }\r\n      }\r\n      // else {\r\n        // if (globalDebug) console.log(`     Right includes ${rPoint.logString()}`, [...right])\r\n      // }\r\n    }\r\n  }\r\n\r\n  // if (globalDebug) console.log(`  Final funnel computed from tail.`, tail)\r\n  let goalEdge = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(apex(), finish)\r\n  let intersectedL = false\r\n  // if (globalDebug) console.log(`   L.`, left)\r\n  for (let l = 0; l < left.length; l++) {\r\n    let lEdge = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(apex(), left[0])\r\n    // if (globalDebug) console.log(`   Goal: ${goalEdge.logString()}`, [goalEdge, lEdge])\r\n    if (lEdge.directionTo(finish) > 0) {\r\n      tail.push(...left.splice(0, 1))\r\n      l--;\r\n      intersectedL = true\r\n      // if (globalDebug) console.log(`   Shortening path (left: ${left.length}).`, tail)\r\n    } else {\r\n      break\r\n    }\r\n    goalEdge = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(apex(), finish)\r\n  }\r\n  if (intersectedL) {\r\n    tail.push(finish)\r\n    // if (globalDebug) console.log(\"Shortest path.\", tail)\r\n    return tail;\r\n  }\r\n\r\n  // if (globalDebug) console.log(`   R.`, right)\r\n  for (let r = 0; r < right.length; r++) {\r\n    let rEdge = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(apex(), right[0])\r\n    // if (globalDebug) console.log(`   Goal: ${goalEdge.logString()}`, [goalEdge, rEdge])\r\n    if (rEdge.directionTo(finish) < 0) {\r\n      tail.push(...right.splice(0, 1))\r\n      r--;\r\n      // if (globalDebug) console.log(`   Shortening path (right: ${right.length}).`, tail)\r\n    } else {\r\n      break\r\n    }\r\n    goalEdge = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(apex(), finish)\r\n  }\r\n\r\n  tail.push(finish)\r\n  // if (globalDebug) console.log(\"Shortest path.\", tail)\r\n  return tail;\r\n}\r\n\r\n/// DEPRECATED: routeHeuristic(nodes[iDestination], next)\r\nfunction routeHeuristic(a, b) {\r\n  let x1 = a.polygon.circumcenter.x\r\n  let y1 = a.polygon.circumcenter.y\r\n  let x2 = b.polygon.circumcenter.x\r\n  let y2 = b.polygon.circumcenter.y\r\n  return Math.abs(x1 - x2) + Math.abs(y1 - y2)\r\n}\r\n\n\n//# sourceURL=webpack://js-2d-pathing/./node_modules/@harxer/engine-2d/helpers/layout/Pathfinding.js?");

/***/ }),

/***/ "./node_modules/@harxer/engine-2d/helpers/layout/Triangulation.js":
/*!************************************************************************!*\
  !*** ./node_modules/@harxer/engine-2d/helpers/layout/Triangulation.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ triangulateGraph)\n/* harmony export */ });\n/* harmony import */ var _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @harxer/geometry */ \"./node_modules/@harxer/geometry/lib/geometry.js\");\n/* harmony import */ var _GraphTriangle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GraphTriangle.js */ \"./node_modules/@harxer/engine-2d/helpers/layout/GraphTriangle.js\");\n/* harmony import */ var _core_World_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/World.js */ \"./node_modules/@harxer/engine-2d/core/World.js\");\n\r\n\r\n\r\n\r\n/** Controls threshold for graph optimization for conjoining triangles. */\r\nlet TRIANGULATION_ANGLE_BOUND = (30) / 180 * Math.PI\r\n\r\n/**\r\n * Apply Delaunay triangulation to obtain an array of edge-sharing triangles.\r\n * @param {Polygon} boundsPolygon Polygon containing all holes for triangulation.\r\n * @param {[Polygon]} holePolygons Holes to be avoided when triangulating.\r\n * @returns {[GraphTriangle]} an array of triangles\r\n */\r\nfunction triangulateGraph(boundsPolygon, holePolygons) {\r\n  if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log('Generating triangulation.', holePolygons, true)\r\n  if (boundsPolygon === undefined) return []\r\n\r\n  /** Wrap vertices in object to prevent modifying Point. @returns {[{vertex: {Point}, convex: {bool}, angle: {int}, eartip: {bool}}]} */\r\n  let graphBuilder = boundsPolygon.vertices.map(vertex => {return { vertex, convex: undefined, angle: undefined, eartip: undefined }})\r\n  const graphEdges = _ => graphBuilder.map(({vertex}, i) => new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(vertex, graphBuilder[(i + 1) % graphBuilder.length].vertex))\r\n\r\n  /** Update graphBuilder node at provided index i with angle attribute. */\r\n  const setNodeInnerAngle = (i) => {\r\n    let node = graphBuilder[i];\r\n\r\n    let vPrev = graphBuilder[(i - 1) < 0 ? graphBuilder.length - 1 : (i - 1)].vertex;\r\n    let v = node.vertex;\r\n    let vNext = graphBuilder[(i + 1) % graphBuilder.length].vertex;\r\n\r\n    let prevVector = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Vector(vPrev.x - v.x, vPrev.y - v.y);\r\n    let nextVector = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Vector(vNext.x - v.x, vNext.y - v.y);\r\n\r\n    let cross = prevVector.crossProduct(nextVector)\r\n    node.angle = Math.acos(prevVector.dotProduct(nextVector) / (prevVector.magnitude * nextVector.magnitude));\r\n    if (cross <= 0 || Number.isNaN(cross)) {\r\n      // Convex\r\n      node.angle = 2 * Math.PI - node.angle;\r\n    }\r\n    if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`  Angle node compute ${node.angle / Math.PI * 180}.`, [new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(v, v.copy.add(prevVector)), new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(v, v.copy.add(nextVector))])\r\n    return node;\r\n  }\r\n\r\n  /** Updates convex and eartip state and angle of node in current graph.\r\n   * Eartip vertices are convex and do not contain any peer vertices inside\r\n   * the triangle formed by its neighbors (\"reflex\" vertices).\r\n   */\r\n  const setNodeData = (_, i) => {\r\n    let node = graphBuilder[i];\r\n\r\n    let vPrev = graphBuilder[(i - 1) < 0 ? graphBuilder.length - 1 : (i - 1)].vertex;\r\n    let v = node.vertex;\r\n    let vNext = graphBuilder[(i + 1) % graphBuilder.length].vertex;\r\n\r\n    let prevVector = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Vector(vPrev.x - v.x, vPrev.y - v.y);\r\n    let nextVector = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Vector(vNext.x - v.x, vNext.y - v.y);\r\n\r\n    let cross = prevVector.crossProduct(nextVector)\r\n\r\n    const PRECISION_BUFFER = 10e3;\r\n    let largestAbsValue = PRECISION_BUFFER  * Math.max(Math.abs(prevVector.x * nextVector.y), Math.abs(prevVector.y * nextVector.x));\r\n\r\n    if ((0,_harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.equals)(cross + largestAbsValue, largestAbsValue) || cross <= 0 || Number.isNaN(cross)) {\r\n      node.convex = false;\r\n      node.eartip = false;\r\n      if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`    Setting node data CROSS:${node.convex}`, [vPrev, v, vNext])\r\n      return\r\n    }\r\n\r\n    if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`    Setting node data. ${cross} from ${largestAbsValue} Cross: ${(0,_harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.equals)(cross + largestAbsValue, largestAbsValue)}, ori: ${(0,_harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.orientation)(vNext, v, vPrev)}`, [new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(vPrev, v), new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(v, vNext)])\r\n\r\n    node.convex = true\r\n    // Get angle between origin-shared vectors\r\n    node.angle = Math.acos(prevVector.dotProduct(nextVector) / (prevVector.magnitude * nextVector.magnitude));\r\n\r\n    let triangle = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Polygon([vNext, v, vPrev]);\r\n    node.eartip = graphBuilder.every(({vertex, convex}) => convex || vertex.equals(vPrev) || vertex.equals(v) || vertex.equals(vNext) || !triangle.containsPoint(vertex));\r\n    // TODO verify `convex ||` above\r\n    if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`      ...EAR: ${node.eartip}`, [new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(vPrev, v), new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(v, vNext)])\r\n  }\r\n\r\n  // Connect holes to bounds using \"bridge\" segments to form one degenerate polygon\r\n  let holePolygonsRemaining = [...holePolygons];\r\n  const I_HOLE = 0; // Always pull from start, if no bridge to bounds, hole is pushed to end\r\n  while (holePolygonsRemaining.length > 0) {\r\n    let hole = holePolygonsRemaining.splice(I_HOLE, 1)[0];\r\n\r\n    // Select shortest \"bridge\" edge connecting hole to bounding polygon. // TODO might not need to get shortest edge (first may work)\r\n    let { bridgeEdge, iHoleVertex } = hole.vertices.reduce((shortestBridge, holeVertex, iHoleVertex) => {\r\n\r\n      // Find all segments that connect a hole to bounds without intersecting itself or neighbors\r\n      let {distSqrd, bridgeCandidate} = graphBuilder\r\n        .map(({vertex: boundsVertex}) => new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(boundsVertex, holeVertex))\r\n        // .forEach(({bridgeCandidate, iBoundsVertex}) => if (globalDebug) console.log(`v ${iBoundsVertex}  `, [bridgeCandidate]))\r\n        .filter(bridgeCandidate => {\r\n          // if (globalDebug) console.log(`  - Bridge candidate`, [bridgeCandidate])\r\n          // Check intersections with this hole's edges - ignoring endpoint overlaps\r\n          return hole.edges.every(holeEdge => {\r\n            // if (globalDebug && !(holeEdge.a.equals(holeVertex) || holeEdge.b.equals(holeVertex) || !holeEdge.intersects(bridgeCandidate))) if (globalDebug) console.log('Intersecting self!', [holeEdge])\r\n            return holeEdge.a.equals(holeVertex) || holeEdge.b.equals(holeVertex) || !holeEdge.intersects(bridgeCandidate);\r\n          }) &&\r\n          // Check intersections with bounds edges - ignoring endpoint overlaps\r\n          graphEdges().every(boundsEdge => {\r\n            // if (globalDebug && !(boundsEdge.a.equals(bridgeCandidate.a) || boundsEdge.b.equals(bridgeCandidate.a) || !boundsEdge.intersects(bridgeCandidate))) if (globalDebug) console.log('Intersecting bounds', [boundsEdge])\r\n            return boundsEdge.a.equals(bridgeCandidate.a) || boundsEdge.b.equals(bridgeCandidate.a) || !boundsEdge.intersects(bridgeCandidate);\r\n          }) &&\r\n          // Check intersections with other hole's edges\r\n          holePolygonsRemaining.every(peerHole => peerHole.edges.every(peerHoleEdge => {\r\n            // if (globalDebug && !(!peerHoleEdge.intersects(bridgeCandidate))) if (globalDebug) console.log('Intersecting peer', [peerHoleEdge])\r\n            return !peerHoleEdge.intersects(bridgeCandidate)\r\n          }))\r\n        })\r\n        .reduce((shortestBridgeCandidate, bridgeCandidate) => {\r\n          let distSqrd = bridgeCandidate.distanceSqrd();\r\n          if (distSqrd < shortestBridgeCandidate.distSqrd) return { distSqrd, bridgeCandidate };\r\n          return shortestBridgeCandidate;\r\n        }, { distSqrd: Infinity })\r\n\r\n      if (distSqrd < shortestBridge.distSqrd) return { distSqrd, iHoleVertex, bridgeEdge: bridgeCandidate}\r\n      return shortestBridge;\r\n    }, {distSqrd: Infinity});\r\n\r\n    if (bridgeEdge === undefined) {\r\n      if (holePolygonsRemaining.length === 1) {\r\n        throw 'No bridges for single hole polygon.'\r\n      }\r\n      if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log('  No bridge edges. Pushing to end.')\r\n      // Push hole to end\r\n      holePolygonsRemaining.push(hole);\r\n      if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log('  Remaining new triangulation.', holePolygonsRemaining)\r\n      continue;\r\n    };\r\n\r\n    if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`Bridge edge generated ${bridgeEdge.logString()} at ${iHoleVertex}`, [bridgeEdge])\r\n\r\n    // Insert hole and bridge vertices into composite polygon // TODO - no need to concat, can just splice it into graphBuilder\r\n    let shiftedHoleVertices = hole.vertices.slice(iHoleVertex + 1).concat(hole.vertices.slice(0, iHoleVertex + 1))\r\n    // if (globalDebug) console.log(`shiftedHoleVertices`, shiftedHoleVertices.concat([new Segment(shiftedHoleVertices[0], shiftedHoleVertices[0].copy.add({x: 0, y: -50}))]))\r\n    // if (globalDebug) console.log(`iBoundsVertex ${iBoundsVertex}`, [new Segment(shiftedHoleVertices[0], shiftedHoleVertices[0].copy.add({x: 0, y: -50}))])\r\n    // Insert bridge and hole into sorted angle angle vertex for overlapped bridge insertions\r\n\r\n    /** Get inner angle if bridge was inserted at given index in graph. */\r\n    const bridgeInnerAngle = function(i) {\r\n      let vPrev = graphBuilder[(i - 1) < 0 ? graphBuilder.length - 1 : (i - 1)].vertex;\r\n      let v = bridgeEdge.a;\r\n      let vNext = bridgeEdge.b;\r\n      let prevVector = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Vector(vPrev.x - v.x, vPrev.y - v.y);\r\n      let nextVector = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Vector(vNext.x - v.x, vNext.y - v.y);\r\n      let cross = prevVector.crossProduct(nextVector)\r\n      let angle = Math.acos(prevVector.dotProduct(nextVector) / (prevVector.magnitude * nextVector.magnitude));\r\n      if (cross <= 0 || Number.isNaN(cross)) {\r\n        // Convex\r\n        angle = 2 * Math.PI - angle;\r\n      }\r\n      if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`  Angle bridge compute ${angle / Math.PI * 180}`, [new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(v, v.copy.add(prevVector)), new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(v, v.copy.add(nextVector))])\r\n      return angle;\r\n    }\r\n\r\n    // Bridge and hole vertices are inserted by...\r\n    let overlappingNodes = graphBuilder\r\n      // ...finding all overlapping bridge insertions (populate angle for next step, if necessary)...\r\n      .filter(({vertex}, iNode) => {\r\n        if (bridgeEdge.a.equals(vertex)) {\r\n          if (bridgeInnerAngle(iNode) > setNodeInnerAngle(iNode).angle) {\r\n            if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`     Excluding vertex ${bridgeInnerAngle(iNode) * 180 / Math.PI} vs ${setNodeInnerAngle(iNode).angle * 180 / Math.PI}`, [vertex])\r\n            return false\r\n          }\r\n          return true;\r\n        }\r\n        return false;\r\n      })\r\n      // ...sorting them by inner angle (populated with previous step)...\r\n      .sort((a, b) => a.angle - b.angle);\r\n    // ...finally insert into sorted angle order.\r\n    let boundsVertexEntry = graphBuilder.indexOf(overlappingNodes[0]);\r\n    if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`First overlap index ${boundsVertexEntry}`, [graphBuilder[boundsVertexEntry].vertex]);\r\n    if (overlappingNodes.length > 1) {\r\n      let insertionAngle = (function() {\r\n        let i = boundsVertexEntry;\r\n        let vPrev = graphBuilder[(i - 1) < 0 ? graphBuilder.length - 1 : (i - 1)].vertex;\r\n        let v = bridgeEdge.a;\r\n        let vNext = bridgeEdge.b;\r\n        let prevVector = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Vector(vPrev.x - v.x, vPrev.y - v.y);\r\n        let nextVector = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Vector(vNext.x - v.x, vNext.y - v.y);\r\n        return Math.acos(prevVector.dotProduct(nextVector) / (prevVector.magnitude * nextVector.magnitude));\r\n      })();\r\n      let iLow = 0, iHigh = overlappingNodes.length;\r\n      while (iLow < iHigh) {\r\n        let iMid = (iLow + iHigh) >>> 1; // Divide by 2 and floor.\r\n        if (overlappingNodes[iMid] < insertionAngle) iLow = iMid + 1;\r\n        else iHigh = iMid;\r\n      }\r\n      boundsVertexEntry = graphBuilder.indexOf(overlappingNodes[iLow]);\r\n      if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`Insertion ${boundsVertexEntry}`, overlappingNodes.map(node => new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(graphBuilder[graphBuilder.indexOf(node)].vertex, graphBuilder[graphBuilder.indexOf(node) + 1].vertex)));\r\n    }\r\n\r\n    // let boundsVertexEntry = graphBuilder.reduce((smallest, node, iNode) => {\r\n    //   // Find overlapping bridge intersections\r\n    //   if (!bridgeEdge.a.equals(node.vertex)) return smallest;\r\n    //   setNodeInnerAngle(iNode);\r\n    //   // if (globalDebug) console.log(`  Vertex angle ${node.angle}`, [node.vertex]);\r\n    //   // Select smallest inner angle\r\n    //   if (node.angle > smallest.angle) return {angle: node.angle, iNode}\r\n    //   return smallest;\r\n    // }, {angle: 0}).iNode;\r\n    // let boundsVertexEntry = graphBuilder.findLastIndex((({vertex}) => bridgeEdge.a.equals(vertex)))\r\n    // if (globalDebug) console.log(`Insert here ${boundsVertexEntry}`, [bridgeEdge, ...graphBuilder.map(({vertex}) => vertex)])\r\n    graphBuilder.splice(boundsVertexEntry, 0, ...[bridgeEdge.a, bridgeEdge.b, ...shiftedHoleVertices].map(vertex => {return { vertex }}))\r\n    // if (globalDebug) console.log('graph', graphBuilder.map(({vertex}) => vertex).filter((node, i) => graphBuilder.every(({vertex: other}, iOther) => i <= iOther || !node.equals(other))))\r\n    // if (globalDebug) graphBuilder.forEach(({vertex}, i) => if (globalDebug) console.log(`graph ${i}`, [vertex]))\r\n  }\r\n\r\n  if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) graphBuilder.forEach(({vertex}, i) => i > 0 ? console.log(`Final graph ${i}`, [new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(graphBuilder[i - 1].vertex, vertex  )]) : undefined)\r\n  graphBuilder.forEach(setNodeData);\r\n\r\n  let triangles = [];\r\n  let n = graphBuilder.length;\r\n  while (triangles.length < n - 2) {\r\n\r\n    // Get smallest graph node by inner angle\r\n    let {node, iNode} = graphBuilder.reduce((smallestAngleNode, node, iNode) => {\r\n      if (!node.eartip) return smallestAngleNode;\r\n      if (node.angle < smallestAngleNode.angle) return {angle: node.angle, node, iNode};\r\n      return smallestAngleNode;\r\n    }, {angle: Infinity});\r\n\r\n    // No eartip nodes available\r\n    if (node === undefined) {\r\n      if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log('No eartips.');\r\n      break;\r\n    };\r\n\r\n    let vPrev = graphBuilder[(iNode - 1) < 0 ? graphBuilder.length - 1 : (iNode - 1)].vertex;\r\n    let v = node.vertex;\r\n    let vNext = graphBuilder[(iNode + 1) % graphBuilder.length].vertex;\r\n\r\n    // Triangulation degenerate polygon is CCW. Vertices are flipped here to form CW polygon\r\n    let triangle = new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Polygon([vNext, v, vPrev])\r\n\r\n    if (false) {}\r\n\r\n    if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`Processing triangle at ${iNode}`, [triangle])\r\n\r\n    triangles.push(triangle);\r\n    graphBuilder.splice(iNode, 1);\r\n\r\n    // update state on prev node\r\n    setNodeData(undefined, (iNode - 1) < 0 ? graphBuilder.length - 1 : (iNode - 1));\r\n    // update state on next node which is now just iNode\r\n    setNodeData(undefined, iNode % graphBuilder.length);\r\n  }\r\n\r\n  let graph = triangles.map(triangle => new _GraphTriangle_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](triangle))\r\n  graph.forEach((node, iNode) => {\r\n\r\n    // Link overlap edges\r\n    node.edges.forEach(graphEdge => {\r\n      let overlapGraphEdge;\r\n      for (let iPeerNode = 0; iPeerNode < graph.length; iPeerNode++) {\r\n        if (iNode === iPeerNode) continue;\r\n        overlapGraphEdge = graph[iPeerNode].edges.find(({edge: peerEdge}) => graphEdge.edge.equals(peerEdge.copy.flip()));\r\n        if (overlapGraphEdge) break;\r\n      }\r\n\r\n      if (overlapGraphEdge === undefined) return;\r\n      graphEdge.linkEdge(overlapGraphEdge);\r\n    })\r\n\r\n    return node;\r\n  })\r\n  if (_core_World_js__WEBPACK_IMPORTED_MODULE_2__.globalDebug) console.log(`Created triangles: ${triangles.length}.`, triangles);\r\n  return graph;\r\n}\r\n\r\n// ======== INTERNAL Helpers =========\r\n\r\n\r\n/** Finds peer edge overlapping this edge (peer would be reversed from target).\r\n * @returns {Vector}\r\n*/\r\nfunction getPeerEdge(peers, edge) {\r\n  if (edge.peer !== undefined) return edge.peer\r\n  for (let p = 0; p < peers.length; p++) {\r\n    let peerPolygon = peers[p]\r\n    if (edge.parent == peerPolygon) continue\r\n    for (let pE = 0; pE < peerPolygon.edges.length; pE++) {\r\n      let peerEdge = peerPolygon.edges[pE]\r\n      if (edge.equals(peerEdge.flip())) return peerEdge\r\n    }\r\n  }\r\n  return undefined\r\n}\r\n\n\n//# sourceURL=webpack://js-2d-pathing/./node_modules/@harxer/engine-2d/helpers/layout/Triangulation.js?");

/***/ }),

/***/ "./node_modules/@harxer/engine-2d/helpers/layout/tools/LayoutManager.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@harxer/engine-2d/helpers/layout/tools/LayoutManager.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addConstructionPoint: () => (/* binding */ addConstructionPoint),\n/* harmony export */   clearConstruction: () => (/* binding */ clearConstruction),\n/* harmony export */   constructionMouseMoveHandler: () => (/* binding */ constructionMouseMoveHandler),\n/* harmony export */   constructionRender: () => (/* binding */ constructionRender),\n/* harmony export */   finishConstruction: () => (/* binding */ finishConstruction),\n/* harmony export */   hasConstructorVertices: () => (/* binding */ hasConstructorVertices),\n/* harmony export */   initLayout: () => (/* binding */ initLayout),\n/* harmony export */   pushLayoutPolygon: () => (/* binding */ pushLayoutPolygon),\n/* harmony export */   reloadDefaultLayout: () => (/* binding */ reloadDefaultLayout),\n/* harmony export */   renderTriangulation: () => (/* binding */ renderTriangulation),\n/* harmony export */   setConstructionSnapDistance: () => (/* binding */ setConstructionSnapDistance),\n/* harmony export */   setDefaultJsonLayoutUrl: () => (/* binding */ setDefaultJsonLayoutUrl),\n/* harmony export */   setLayoutCookieKey: () => (/* binding */ setLayoutCookieKey),\n/* harmony export */   setLayoutPolygons: () => (/* binding */ setLayoutPolygons),\n/* harmony export */   setPathfindingRoute: () => (/* binding */ setPathfindingRoute),\n/* harmony export */   triangulationVisible: () => (/* binding */ triangulationVisible),\n/* harmony export */   undoConstructionPoint: () => (/* binding */ undoConstructionPoint),\n/* harmony export */   visibleTriangulation: () => (/* binding */ visibleTriangulation),\n/* harmony export */   writeLayout: () => (/* binding */ writeLayout)\n/* harmony export */ });\n/* harmony import */ var _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @harxer/geometry */ \"./node_modules/@harxer/geometry/lib/geometry.js\");\n/* harmony import */ var _Layout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Layout.js */ \"./node_modules/@harxer/engine-2d/helpers/layout/Layout.js\");\n\r\n\r\n\r\nlet constructingVertices = [];\r\nconst hasConstructorVertices = _ => constructingVertices.length > 0;\r\nlet _constructingCcw = false;\r\n\r\nlet constructionMouse = undefined;\r\nconst constructionSnappingEnabled = _ => constructionMouse !== undefined;\r\nlet constructionSnapDistance = 8; // pixels\r\nlet _withinSnapDistance = false;\r\nfunction setConstructionSnapDistance(val) {\r\n  constructionSnapDistance = val;\r\n  constructionSnapping = true;\r\n}\r\n\r\nlet pathfindingRoute = []\r\nfunction setPathfindingRoute(route) {\r\n  let pathBuilder = []\r\n  for (let p = 1; p < (route.path || []).length; p++) {\r\n    pathBuilder.push(new _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment(route.path[p-1], route.path[p]))\r\n  }\r\n  pathfindingRoute = pathBuilder;\r\n}\r\n\r\n/** @type {boolean} */\r\nlet visibleTriangulation = false;\r\n/** Update visibleTriangulation flag. @param {boolean} val  */\r\nfunction triangulationVisible(val) {\r\n  visibleTriangulation = val;\r\n}\r\n\r\nlet layoutPolygons = [];\r\nfunction setLayoutPolygons(polygons) {\r\n  layoutPolygons = polygons;\r\n}\r\nfunction pushLayoutPolygon(polygon) {\r\n  layoutPolygons.push(polygon);\r\n}\r\n\r\n/** Add construction point. Finish construction if endpoints overlap. @param {Layout} layout @param {Point} p */\r\nfunction addConstructionPoint(layout, p) {\r\n  // If using a mouse listener, snapping is enabled\r\n  if (constructionSnappingEnabled() && constructingVertices.length >= 3) {\r\n    let distMouseToStartSqrd = _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment.distanceSqrd(p, constructingVertices[0])\r\n    // Complete construction if within snap distance\r\n    if (distMouseToStartSqrd < Math.pow(constructionSnapDistance, 2)) {\r\n      finishConstruction(layout);\r\n      return;\r\n    }\r\n  }\r\n\r\n  constructingVertices.push(p);\r\n  syncConstructingCcw();\r\n}\r\n\r\n/** Removes last construction point if any exist. */\r\nfunction undoConstructionPoint() {\r\n  if (!hasConstructorVertices()) return;\r\n  constructingVertices.pop();\r\n  syncConstructingCcw();\r\n}\r\n\r\n/** Finish construction with current vertices. @param {Layout} layout   */\r\nfunction finishConstruction(layout) {\r\n  if (constructingVertices.length > 2) layout.insertContextHole(constructingVertices)\r\n  clearConstruction();\r\n  writeLayout(layout);\r\n}\r\n\r\n/** Remove any construction points. */\r\nfunction clearConstruction() {\r\n  constructingVertices = [];\r\n  _constructingCcw = false\r\n  constructionMouse = undefined;\r\n}\r\n\r\n/** Draw layout polygons and construction vertices to given context. */\r\nfunction constructionRender(context) {\r\n  // Draw postprocessed blocker\r\n  layoutPolygons.forEach(blocker => {\r\n    if (blocker === undefined) return\r\n    // Draw boundaries\r\n    context.strokeStyle = \"gray\";\r\n    context.beginPath();\r\n    blocker.vertices.forEach((vertex, i) => {\r\n      if (i == 0) {\r\n        context.moveTo(vertex.x, vertex.y);\r\n      } else {\r\n        context.lineTo(vertex.x, vertex.y);\r\n      }\r\n    });\r\n    context.lineTo(blocker.vertices[0].x, blocker.vertices[0].y);\r\n    context.stroke();\r\n\r\n    // Draw holes\r\n    context.fillStyle = \"rgba(0, 0, 0, 0.6)\";\r\n    blocker.holes.forEach((hole) => {\r\n      hole.vertices.forEach((vertex, i) => {\r\n        if (i == 0) {\r\n          context.beginPath();\r\n          context.moveTo(vertex.x, vertex.y);\r\n        } else {\r\n          context.lineTo(vertex.x, vertex.y);\r\n        }\r\n      });\r\n      context.lineTo(hole.vertices[0].x, hole.vertices[0].y);\r\n      context.fill();\r\n    });\r\n  });\r\n\r\n  context.strokeStyle = _constructingCcw ? \"Blue\" : \"Red\";\r\n  context.fillStyle = _constructingCcw ? \"Blue\" : \"Red\";\r\n  context.font = '14px sans-serif';\r\n  for (let c = 0; c < constructingVertices.length; c++) {\r\n    let vertex = constructingVertices[c];\r\n\r\n    context.beginPath();\r\n    context.arc(vertex.x, vertex.y, 3, 0, 2 * Math.PI, false);\r\n    context.stroke();\r\n\r\n    if (c == 0) {\r\n      if (constructionSnappingEnabled()) {\r\n        if (_withinSnapDistance) {\r\n          if (constructingVertices.length >= 3) {\r\n            context.fillText('Close Polygon', vertex.x+5, vertex.y-5);\r\n          } else {\r\n            context.fillText('Not enough vertices', vertex.x+5, vertex.y-5);\r\n          }\r\n        } else {\r\n          context.fillText(vertex.logString(), vertex.x+5, vertex.y-5);\r\n        }\r\n      } else {\r\n        context.fillText(vertex.logString(), vertex.x+5, vertex.y-5);\r\n      }\r\n    }\r\n\r\n    // Connect vertices by line\r\n    if (c > 0) {\r\n      context.beginPath();\r\n      context.moveTo(constructingVertices[c-1].x, constructingVertices[c-1].y);\r\n      context.lineTo(vertex.x, vertex.y);\r\n      context.stroke();\r\n      context.fillText(vertex.logString(), vertex.x+5, vertex.y-5);\r\n    }\r\n    // Last vertex\r\n    if (c == constructingVertices.length - 1 && constructionSnappingEnabled()) {\r\n\r\n      // Connect to mouse or last start vertex\r\n      context.beginPath();\r\n      context.moveTo(vertex.x, vertex.y);\r\n      if (_withinSnapDistance) {\r\n        context.lineTo(constructingVertices[0].x, constructingVertices[0].y);\r\n      } else {\r\n        context.lineTo(constructionMouse.x, constructionMouse.y);\r\n      }\r\n      context.stroke();\r\n    }\r\n  }\r\n}\r\n\r\n/** Render triangulation. @param {Layout} layout @param {CanvasRenderingContext2D} context   */\r\nfunction renderTriangulation(layout, context) {\r\n  if (layout === undefined || layout.meshContext === undefined) return;\r\n\r\n  layout.meshContext.triangulatedGraph?.forEach(({triangle: polygon}) => {\r\n    context.strokeStyle = \"rgba(50, 50, 200, 0.2)\"\r\n    context.fillStyle = \"rgba(55, 55, 180, 0.1)\"\r\n    if (polygon.highlighted !== undefined && polygon.highlighted) {\r\n      context.fillStyle = \"rgba(50, 50, 200, 0.2)\"\r\n    }\r\n    context.beginPath();\r\n    context.moveTo(polygon.vertices[0].x, polygon.vertices[0].y);\r\n    polygon.vertices.forEach(vertex => context.lineTo(vertex.x, vertex.y))\r\n    context.lineTo(polygon.vertices[0].x, polygon.vertices[0].y);\r\n    if (polygon.counterclockwise) context.fill()\r\n    if (visibleTriangulation) context.stroke();\r\n  });\r\n\r\n  context.lineWidth = 3\r\n  context.strokeStyle = \"rgb(255, 120, 0 )\"\r\n  context.beginPath()\r\n  if (pathfindingRoute.length) context.moveTo(pathfindingRoute[0].a.x, pathfindingRoute[0].a.y)\r\n  pathfindingRoute.forEach(segment => context.lineTo(segment.b.x, segment.b.y))\r\n  context.stroke()\r\n  context.lineWidth = 1\r\n}\r\n\r\n/** Handle mouse update. Allows for snapping when creating blockers */\r\nfunction constructionMouseMoveHandler(x, y) {\r\n  if (constructingVertices.length === 0) {\r\n    constructionMouse = undefined;\r\n    return;\r\n  }\r\n  constructionMouse = {x, y}\r\n\r\n  // If using a mouse listener, snapping is enabled\r\n  let distMouseToStartSqrd = _harxer_geometry__WEBPACK_IMPORTED_MODULE_0__.Segment.distanceSqrd(constructionMouse, constructingVertices[0])\r\n  _withinSnapDistance = distMouseToStartSqrd < Math.pow(constructionSnapDistance, 2);\r\n}\r\n\r\n/** INTERNAL: Memoizes current construction CCW state. */\r\nfunction syncConstructingCcw() {\r\n  let averageSlope = 0\r\n  for (let i = 0; i < constructingVertices.length; i++) {\r\n    let v = constructingVertices[i]\r\n    let vNext = constructingVertices[(i + 1) % constructingVertices.length]\r\n    averageSlope += (vNext.x - v.x) * (vNext.y + v.y)\r\n  }\r\n  _constructingCcw = (averageSlope > 0)\r\n}\r\n\r\n// ======================================================================================= Cookie Helpers ====\r\n\r\n/** INTERNAL: Cookie set helper */\r\nfunction setCookie(cname, cvalue, exdays) {\r\n  var d = new Date();\r\n  d.setTime(d.getTime() + (exdays*24*60*60*1000));\r\n  var expires = \"expires=\"+ d.toUTCString();\r\n  document.cookie = cname + \"=\" + cvalue + \";\" + expires + \";path=/\";\r\n}\r\n\r\n/** INTERNAL: Cookie get helper */\r\nfunction getCookie(cname) {\r\n  var name = cname + \"=\";\r\n  var decodedCookie = decodeURIComponent(document.cookie);\r\n  var ca = decodedCookie.split(';');\r\n  for(var i = 0; i <ca.length; i++) {\r\n    var c = ca[i];\r\n    while (c.charAt(0) == ' ') {\r\n      c = c.substring(1);\r\n    }\r\n    if (c.indexOf(name) == 0) {\r\n      return c.substring(name.length, c.length);\r\n    }\r\n  }\r\n  return \"\";\r\n}\r\n\r\n// ==================================================================================== Serialization Helpers ===\r\n\r\nlet defaultJsonLayoutUrl = 'javascript/Layout2D/layout_default.json';\r\nfunction setDefaultJsonLayoutUrl(val) {\r\n  defaultJsonLayoutUrl = val;\r\n}\r\n\r\nlet layoutCookieKey = 'layoutData';\r\nfunction setLayoutCookieKey(val) {\r\n  layoutCookieKey = val;\r\n}\r\n\r\nfunction reloadDefaultLayout() {\r\n  setCookie(layoutCookieKey, '', 0)\r\n  // Else load default server layout JSON\r\n  let xmlhttp = new XMLHttpRequest();\r\n  return new Promise((resolve) => {\r\n    xmlhttp.onreadystatechange = function() {\r\n      if (this.readyState == 4 && this.status == 200) {\r\n        let parsedLayout = _Layout_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromJson(this.responseText);\r\n        // Save to cookies\r\n        setCookie(layoutCookieKey, parsedLayout.serialized(), 365)\r\n        return resolve(parsedLayout)\r\n      }\r\n    };\r\n    xmlhttp.open(\"GET\", defaultJsonLayoutUrl, true);\r\n    xmlhttp.send();\r\n  })\r\n}\r\n\r\n/** Write given layout to cookies. @param {Layout} layout  */\r\nfunction writeLayout(layout) {\r\n  setCookie(layoutCookieKey, layout.serialized(), 365)\r\n}\r\n\r\nfunction initLayout() {\r\n  // Try to load layout from cookies\r\n  let cookieData = getCookie(layoutCookieKey)\r\n  if (cookieData !== '') {\r\n    return Promise.resolve(_Layout_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromJson(cookieData));\r\n  } else {\r\n    return reloadDefaultLayout();\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://js-2d-pathing/./node_modules/@harxer/engine-2d/helpers/layout/tools/LayoutManager.js?");

/***/ }),

/***/ "./node_modules/@harxer/geometry/lib/geometry.js":
/*!*******************************************************!*\
  !*** ./node_modules/@harxer/geometry/lib/geometry.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ANGLE: () => (/* binding */ ANGLE),\n/* harmony export */   MAX_FLOAT_PRECISION: () => (/* binding */ MAX_FLOAT_PRECISION),\n/* harmony export */   ORIENTATION: () => (/* binding */ ORIENTATION),\n/* harmony export */   Point: () => (/* reexport safe */ _structures_point_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   Polygon: () => (/* reexport safe */ _structures_polygon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   Segment: () => (/* reexport safe */ _structures_segment_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   Vector: () => (/* reexport safe */ _structures_vector_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   angleDiff: () => (/* binding */ angleDiff),\n/* harmony export */   anglesMatch: () => (/* binding */ anglesMatch),\n/* harmony export */   boundAngle: () => (/* binding */ boundAngle),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   equals: () => (/* binding */ equals),\n/* harmony export */   globalEqualsPrecision: () => (/* binding */ globalEqualsPrecision),\n/* harmony export */   magnitudeOrder: () => (/* binding */ magnitudeOrder),\n/* harmony export */   minNumber: () => (/* binding */ minNumber),\n/* harmony export */   orientation: () => (/* binding */ orientation),\n/* harmony export */   setGlobalEqualsPrecision: () => (/* binding */ setGlobalEqualsPrecision),\n/* harmony export */   validNumber: () => (/* binding */ validNumber)\n/* harmony export */ });\n/* harmony import */ var _structures_polygon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./structures/polygon.js */ \"./node_modules/@harxer/geometry/lib/structures/polygon.js\");\n/* harmony import */ var _structures_point_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./structures/point.js */ \"./node_modules/@harxer/geometry/lib/structures/point.js\");\n/* harmony import */ var _structures_segment_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./structures/segment.js */ \"./node_modules/@harxer/geometry/lib/structures/segment.js\");\n/* harmony import */ var _structures_vector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./structures/vector.js */ \"./node_modules/@harxer/geometry/lib/structures/vector.js\");\n/**\r\n * Geometry Library\r\n * @author Harrison \"Harxer\" Balogh\r\n * @usage import { Segment, Vector, Polygon, Point } from './Layout2D/Geometry.js'\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/** Highest inverse order of magnitude precision for JS numbers. */\r\nconst MAX_FLOAT_PRECISION = 16;\r\n\r\n/**\r\n * Equality check inverse order of magnitude for floating points. Override with `setGlobalEqualsPrecision()`.\r\n * Default to three orders of magnitude lower than max JS float point precision.\r\n */\r\nlet globalEqualsPrecision = MAX_FLOAT_PRECISION - 3;\r\n\r\n/** Override the default 16 decimal places of precision check. */\r\nfunction setGlobalEqualsPrecision(precision) {\r\n  if (!Number.isFinite(precision)) throw Error(`[GEOMETRY ERROR]: Precision is not an integer: ${precision}`);\r\n  globalEqualsPrecision = precision;\r\n}\r\n\r\n/** Pre-computed precision comparator values. \"Number.EPSILON * Math.pow(10, 16 - precision)\" */\r\nconst PRECISION_MAP = {\r\n  0: 2.220446049250313,\r\n  1: 0.2220446049250313,\r\n  2: 0.02220446049250313,\r\n  3: 0.002220446049250313,\r\n  4: 0.0002220446049250313,\r\n  5: 0.00002220446049250313,\r\n  6: 0.000002220446049250313,\r\n  7: 2.220446049250313e-7,\r\n  8: 2.220446049250313e-8,\r\n  9: 2.220446049250313e-9,\r\n  10: 2.220446049250313e-10,\r\n  11: 2.220446049250313e-11,\r\n  12: 2.220446049250313e-12,\r\n  13: 2.220446049250313e-13,\r\n  14: 2.220446049250313e-14,\r\n  15: 2.220446049250313e-15,\r\n  16: 2.220446049250313e-16, // Number.EPSILON\r\n}\r\n\r\n\r\n\r\nconst ORIENTATION = {\r\n  CCW: -1,\r\n  COLLINEAR: 0,\r\n  CW: 1\r\n}\r\n\r\n/**\r\n * Returns orientation of ordered triplet.\r\n *\r\n * @returns 0 for collinear. 1 for cw. 2 for ccw.\r\n */\r\nfunction orientation(p1, p2, p3) {\r\n  let dY_p1p2 = (p2.y - p1.y);\r\n  let dX_p1p2 = (p2.x - p1.x);\r\n  let dX_p2p3 = (p3.x - p2.x);\r\n  let dY_p2p3 = (p3.y - p2.y);\r\n\r\n  // Handle Infinity - allow `0 * Infinity === 0` rather than `=== NaN`\r\n  if (equals(dY_p1p2, 0) || equals(dX_p2p3, 0)) { dY_p1p2 = 0; dX_p2p3 = 0; }\r\n  if (equals(dX_p1p2, 0) || equals(dY_p2p3, 0)) { dX_p1p2 = 0; dY_p2p3 = 0; } // TODO dY_p2p3 === 4 is a typo?\r\n\r\n  let val = dY_p1p2 * dX_p2p3 - dX_p1p2 * dY_p2p3;\r\n  if (equals(val, 0)) return ORIENTATION.COLLINEAR;\r\n  return (val > 0) ? ORIENTATION.CCW : ORIENTATION.CW\r\n}\r\n\r\n/**\r\n * Clamps input angle.\r\n * @note The returned value, despite being small, will have the floating point precision of the incoming argument.\r\n * @param {int} angle radians\r\n * @returns {int} radians [0, 2PI).\r\n */\r\nfunction boundAngle(angle) {\r\n  let twoPi = 2 * Math.PI\r\n  if (angle < 0) return twoPi + (angle) % twoPi\r\n  if (angle >= twoPi) return angle % twoPi\r\n  return angle\r\n}\r\n\r\nfunction angleDiff(val1, val2) {\r\n  let angle1 = boundAngle(val1)\r\n  let angle2 = boundAngle(val2)\r\n  let diff = boundAngle(angle2 - angle1)\r\n  if (diff > Math.PI) diff -= 2 * Math.PI\r\n  return diff\r\n}\r\n\r\nconst ANGLE = {\r\n  CLOCKWISE: 1,\r\n  COUNTERCLOCKWISE: -1,\r\n  EQUAL: 0\r\n}\r\n\r\n/**\r\n * Check if target vectors angle matches given vector's angle within\r\n * threshold. Threshold defaults to 1deg.\r\n * @param {Vector} peer\r\n * @param {int} threshold - Default 1deg\r\n * @returns\r\n *  - `0` if difference within threshold\r\n *  - `1` if val1 is larger\r\n *  - `-1` if val2 is larger\r\n */\r\nfunction anglesMatch(val1, val2, threshold = 0.01745) {\r\n  let angle1 = boundAngle(val1)\r\n  let angle2 = boundAngle(val2)\r\n  let diff = angle1 - angle2\r\n  if (Math.abs(diff) <= threshold || Math.abs(diff) >= 2 * Math.PI - threshold) return 0\r\n  return (diff < Math.PI && diff > 0) || (diff < - Math.PI) ? -1 : 1\r\n}\r\n\r\n/** Return val bounded by min/max. @returns {int} */\r\nfunction clamp(val, min, max) {\r\n  if (val < min) return min;\r\n  if (val > max) return max;\r\n  return val;\r\n}\r\n\r\n/** Compare numbers for equality. If either inputs are non-numbers, returns false. */\r\nfunction equals(x, y, precision = undefined) {\r\n  if (x === Infinity || y === Infinity || x === -Infinity || y === -Infinity) {\r\n    // Avoid subtracting Infinity values (NaN)\r\n    return ((x === Infinity && y === Infinity) || (x === -Infinity && y === -Infinity));\r\n  }\r\n  if (!validNumber(x) || !validNumber(y)) return false;\r\n\r\n  if (precision === undefined) {\r\n    // Dynamic precision based on magnitude of two numbers being compared up to `globalEqualsPrecision`.\r\n    // TODO - Math.max(), if values are significantly different magnitudes, why refine precision?\r\n    precision = globalEqualsPrecision - magnitudeOrder(Math.max(Math.abs(x), Math.abs(y))) + 1;\r\n  }\r\n  // Less than \"Math.pow(10, -) / 2\":\r\n  return Math.abs(y - x) < PRECISION_MAP[Math.max(precision, 0)];\r\n}\r\n\r\n/** The smallest value floating point can handle with one whole number.\r\n * The higher magnitude whole number, the smaller magnitude decimal.\r\n * @param {int} scaleReference Provide a number here to return a more\r\n * accurate minimum value. This can be the number minNumber is being added\r\n * or compared to, and will reduce the precision of the returned value\r\n * relative to the magnitude of the value provided.\r\n * @usage `minNumber(0.5)` may return ~`1e-16`. Adding this to `0.5` will\r\n * result in no digit loss. But if you added 1e-16 to `500000`,\r\n * there would about 6 decimal places of digits removed. This matters when comparing\r\n * values. If you use `minNumber(500000)`, this would return a number ~`1e-10`. Adding\r\n * this value to `500000` would not lose any digits.\r\n */\r\nfunction minNumber(scaleReference = 1) {\r\n  return Number.EPSILON * Math.pow(10, magnitudeOrder(scaleReference) - 1);\r\n}\r\n\r\n/** Precision order of magnitude for given number. @param {int} num to process. @returns {int} */\r\nfunction magnitudeOrder(num) {\r\n  num = Math.abs(num);\r\n  if (num === Infinity) return Infinity;\r\n  if (num < 10) return 1;\r\n  return num.toString().split('.')[0].length;\r\n}\r\n\r\n/** Checks if passed value is a number (allows Infinity).\r\n * @param {int} num to validate\r\n * @returns {boolean} true if num is a number/Infinity, else false\r\n */\r\nfunction validNumber(num) {\r\n  if (num === Infinity || num === -Infinity) return true;\r\n  if (Number.isFinite(num)) return true;\r\n  return false;\r\n}\r\n\n\n//# sourceURL=webpack://js-2d-pathing/./node_modules/@harxer/geometry/lib/geometry.js?");

/***/ }),

/***/ "./node_modules/@harxer/geometry/lib/structures/point.js":
/*!***************************************************************!*\
  !*** ./node_modules/@harxer/geometry/lib/structures/point.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Point)\n/* harmony export */ });\n/* harmony import */ var _geometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry.js */ \"./node_modules/@harxer/geometry/lib/geometry.js\");\n/* harmony import */ var _vector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vector.js */ \"./node_modules/@harxer/geometry/lib/structures/vector.js\");\n\n\n\n/** 2D Point structure */\nclass Point {\n  /** Create 2D location structure.\n   * @param {int} x Component\n   * @param {int} y Component\n   * @throws if components are not valid numbers\n   */\n  constructor(x, y) {\n    if (!(0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.validNumber)(x)) throw Error(`[POINT INIT ERROR]: X not an integer: ${x}`);\n    if (!(0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.validNumber)(y)) throw Error(`[POINT INIT ERROR]: Y not an integer: ${y}`);\n    this._x = x;\n    this._y = y;\n  }\n\n  /** Structure's x location. @returns {integer} */\n  get x() {\n    return this._x;\n  }\n  set x(val) {\n    if (!(0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.validNumber)(val)) throw Error(`Cannot set X to non-integer: ${val}`);\n    this._x = val;\n  }\n  /** Structure's y location. @returns {integer} */\n  get y() {\n    return this._y;\n  }\n  set y(val) {\n    if (!(0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.validNumber)(val)) throw Error(`Cannot set Y to non-integer: ${val}`);\n    this._y = val;\n  }\n\n  /** Copies the target x/y properties. @returns {Point} */\n  get copy() {\n    return new Point(this._x, this._y);\n  }\n\n  /** Creates a Vector structure out of point coordinates. @returns {Vector} */\n  get vector() {\n    return new _vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.x, this.y);\n  }\n\n  /** Compares x/y components for equility. @param {Point} peer @param {int?} precision optional @returns {boolean} */\n  equals(peer, precision = undefined) {\n    if (peer === undefined) return false;\n    return (0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.equals)(this.x, peer.x, precision) && (0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.equals)(this.y, peer.y, precision);\n  }\n\n  /** Test target Point for overlap with passed Segment.\n   * @param {Segment} segment\n   * @returns {boolean} true if overlapping segment or its endpoints\n   */\n  isOnSegment(segment) {\n    if (!_geometry_js__WEBPACK_IMPORTED_MODULE_0__.Segment.typeOf(segment)) throw Error('Non-Segment object passed')\n    if (this.equals(segment.a) || this.equals(segment.b)) return true;\n    if (\n      this.x > Math.max(segment.a.x, segment.b.x) ||\n      this.x < Math.min(segment.a.x, segment.b.x) ||\n      this.y > Math.max(segment.a.y, segment.b.y) ||\n      this.y < Math.min(segment.a.y, segment.b.y)) {\n        return false;\n    }\n    let largestScale = Math.max(segment.a.x, segment.a.y, segment.b.x, segment.b.y, this.x, this.y);\n    // TODO replace slope compare with quadrant compare\n    if ((0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.equals)((new _geometry_js__WEBPACK_IMPORTED_MODULE_0__.Segment(segment.a, this)).slope, segment.slope, _geometry_js__WEBPACK_IMPORTED_MODULE_0__.globalEqualsPrecision - (0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.magnitudeOrder)(largestScale) + 1)) return true\n    return false;\n  }\n\n  /** Serializes structure to a string. @returns {string} */\n  logString() {\n    return `(${this.x}, ${this.y})`;\n  }\n\n  /** Gets plain JS object used for serialization. */\n  json() {\n    return {x: this.x, y: this.y};\n  }\n\n  /** Move point in direction of given vector. @param {Vector} vector @returns {Point} this */\n  add(vector) {\n    this._x += vector.x;\n    this._y += vector.y;\n    return this;\n  }\n\n  /** Move point in negative direction of given vector. @param {Vector} vector @returns {Point} this */\n  minus(vector) {\n    this._x -= vector.x;\n    this._y -= vector.y;\n    return this;\n  }\n\n  /**\n   * Determine if given object behaves like a point.\n   * @param {*} testStructure\n   * @returns {boolean} true if testStructure has an `x` and `y`.\n   */\n  static typeOf(testStructure) {\n    return testStructure?.x !== undefined && testStructure?.y != undefined;\n  }\n}\n\n\n//# sourceURL=webpack://js-2d-pathing/./node_modules/@harxer/geometry/lib/structures/point.js?");

/***/ }),

/***/ "./node_modules/@harxer/geometry/lib/structures/polygon.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@harxer/geometry/lib/structures/polygon.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Polygon)\n/* harmony export */ });\n/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.js */ \"./node_modules/@harxer/geometry/lib/structures/point.js\");\n/* harmony import */ var _segment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./segment.js */ \"./node_modules/@harxer/geometry/lib/structures/segment.js\");\n/* harmony import */ var _vector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vector.js */ \"./node_modules/@harxer/geometry/lib/structures/vector.js\");\n/* harmony import */ var _geometry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geometry.js */ \"./node_modules/@harxer/geometry/lib/geometry.js\");\n\n\n\n\n\nclass Polygon {\n  /**\n   * @param {[Point]} vertices Boundary vertices\n   * @param {[Polygon]} holes Internal polygon holes\n   */\n  constructor(vertices, holes) {\n    if (!Array.isArray(vertices)) throw Error(`[POLYGON INIT ERROR] vertices not array: ${vertices}`)\n    if (vertices.length <= 2) throw Error(`[POLYGON INIT ERROR] 3 vertices required to make a polygon: ${vertices.length}`)\n\n    this._vertices = [];\n    for (let vertex of vertices) {\n      if (typeof vertex === 'object') {\n        if (!(0,_geometry_js__WEBPACK_IMPORTED_MODULE_3__.validNumber)(vertex.x)) throw Error(`[POLYGON INIT ERROR]: X component not an integer: ${vertex.x}`);\n        if (!(0,_geometry_js__WEBPACK_IMPORTED_MODULE_3__.validNumber)(vertex.y)) throw Error(`[POLYGON INIT ERROR]: Y component not an integer: ${vertex.y}`);\n        vertex = new _point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](vertex.x, vertex.y);\n      }\n      this._vertices.push(vertex);\n    }\n\n    let excessVertices = [];\n    // Verify if any vertices overlap/intersect\n    for (let iEdgeA = 0; iEdgeA < this.edges.length - 1; iEdgeA++) {\n      for (let iEdgeB = iEdgeA + 1; iEdgeB < this.edges.length; iEdgeB++) {\n\n        if (iEdgeB === iEdgeA + 1) {\n          // Immediate neighbors only get checked for the non-shared endpoint is collinear as `intersects()` would always result in true\n          if ((0,_geometry_js__WEBPACK_IMPORTED_MODULE_3__.orientation)(this.edges[iEdgeA].a, this.edges[iEdgeA].b, this.edges[iEdgeB].b) === _geometry_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION.COLLINEAR) {\n            if (this.edges[iEdgeA].vector.quadrant() === this.edges[iEdgeB].vector.quadrant()) {\n              // Repair collinear continued segments, remove excess vertices\n              excessVertices.push(iEdgeA + 1);\n            } else {\n              // Verify no overlap, no backtracking\n              throw Error(`[POLYGON INIT ERROR] edge neighbors collinear: ${this.edges[iEdgeA].logString()} with ${this.edges[iEdgeB].logString()}`);\n            }\n          }\n          // TODO auto repair endpoint overlap\n        } else if (iEdgeA === 0 && iEdgeB === this.edges.length - 1) {\n          // First edge has to ignore endpoint overlap with closing edge\n          if ((0,_geometry_js__WEBPACK_IMPORTED_MODULE_3__.orientation)(this.edges[iEdgeB].a, this.edges[iEdgeB].b, this.edges[iEdgeA].b) == _geometry_js__WEBPACK_IMPORTED_MODULE_3__.ORIENTATION.COLLINEAR) {\n            throw Error(`[POLYGON INIT ERROR] closing edge collinear: ${this.edges[iEdgeA].logString()} with ${this.edges[iEdgeB].logString()}`);\n          }\n        } else if (this.edges[iEdgeA].intersects(this.edges[iEdgeB])) {\n          throw Error(`[POLYGON INIT ERROR] edges intersect: ${this.edges[iEdgeA].logString()} with ${this.edges[iEdgeB].logString()}`);\n        }\n      }\n    }\n    if (excessVertices.length) {\n      // TODO move this first populating this._vertices\n      this._vertices = this._vertices.filter((_, i) => !excessVertices.includes(i));\n      // regenerate edges after vertex manipulation\n      this._edges = undefined;\n      this.edges;\n    }\n\n    // Verify vertices are not collinear\n    this.clockwise;\n\n    // TODO - Test holes for overlap with boundary\n    //\n\n    // TODO - a polygon should not have parallel edges so close there is\n    // no amount of gap between them. This is confusing for triangulation\n    // and when finding nearest point outside of a polygon. It also conceptually\n    // defeats the purpose of the polygon blocking out spaces. This case should\n    // conjoin the two blockers into one or break apart a blocker into two.\n\n    // Reference to hole polygons relative to this polygon\n    this.holes = (holes === undefined) ? [] : holes\n  }\n\n  get vertices() {\n    return this._vertices;\n  }\n  set vertices(_) { throw Error('Cannot modify vertices of a Polygon structure.') }\n\n  /** Get vertices as connected segments @returns {[Segment]} */\n  get edges() {\n    if (this._edges === undefined) {\n      let edges = []\n      this.vertices.forEach((vertex, v) => {\n        edges.push(new _segment_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](vertex, this.vertices[(v + 1) % this.vertices.length]))\n      })\n      edges.forEach(edge => edge.parent = this)\n      this._edges = edges\n    }\n    return this._edges;\n  }\n  set edges(_) { throw Error('Cannot modify edges of Polygon structure.') }\n\n  /** Get average center of all vertices */\n  get circumcenter() {\n    if (this._circumcenter === undefined) {\n      let sumVertices = this.vertices.reduce(({x, y}, vertex) => {return {x: x + vertex.x, y: y + vertex.y}}, {x: 0, y: 0});\n      this._circumcenter = new _point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](sumVertices.x / this.vertices.length, sumVertices.y / this.vertices.length);\n    }\n    return this._circumcenter;\n  }\n  set circumcenter(_) { throw Error('Cannot modify circumcenter of Polygon structure.') }\n\n  /** Get circumradius (smallest bounding circle) */\n  get circumradius() {\n    if (this._circumradius === undefined) {\n      let furthestVertexSqrd = this.vertices.reduce((furthest, vertex) => Math.max(furthest, _segment_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].distanceSqrd(this.circumcenter, vertex)), 0);\n      this._circumradius = Math.sqrt(furthestVertexSqrd);\n    }\n    return this._circumradius;\n  }\n  set circumradius(_) { throw Error('Cannot modify circumradius of Polygon structure.') }\n\n  /** Get clockwise rule */\n  get clockwise() {\n    if (this._clockwise === undefined) {\n      let averageSlope = this.edges.reduce((sum, edge) => sum + (edge.b.x - edge.a.x) * (edge.b.y + edge.a.y), 0);\n      // for (let i = 0; i < this._vertices.length; i++) {\n      //   let v = this._vertices[i]\n      //   let vNext = this._vertices[(i + 1) % this._vertices.length]\n      //   averageSlope += (vNext.x - v.x) * (vNext.y + v.y)\n      // }\n      if ((0,_geometry_js__WEBPACK_IMPORTED_MODULE_3__.equals)(averageSlope, 0)) throw Error('[POLYGON INIT ERROR] vertices are colllinear')\n      this._clockwise = (averageSlope > 0)\n    }\n    return this._clockwise;\n  }\n  set clockwise(_) { throw Error('Cannot modify clockwise state of Polygon structure.') }\n  get counterclockwise() { return !this.clockwise; }\n  set counterclockwise(_) { throw Error('Cannot modify counterclockwise state of Polygon structure.') }\n\n  /** TODO: Optimize @returns {Polygon} */\n  get copy() {\n    return new Polygon(this.vertices);\n  }\n\n  // --------------------------\n\n  // TODO - simplify alg: https://stackoverflow.com/questions/36399381/whats-the-fastest-way-of-checking-if-a-point-is-inside-a-polygon-in-python\n  /** Check if given point is inside polygon - external to polygon if structure is clockwise.\n   * @param {Point} p point to check\n   * @returns {bool} true if point is internal or lies on structure's edge/vertex (for clockwise).\n   */\n  containsPoint(p) {\n    let pInfiniteX = new _segment_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](p, {x: Infinity, y: p.y});\n    let count = 0;\n    for (let i = 0; i < this.edges.length; i++) {\n      let edge = this.edges[i];\n      // if (p.equals(edge.a) || p.equals(edge.b)) return false // TODO review change\n      if (p.isOnSegment(edge)) return this.counterclockwise;\n      if (edge.intersects(pInfiniteX)) {\n        // Ensure not y-aligned with endpoint, only allow B, skip A\n        if (!(0,_geometry_js__WEBPACK_IMPORTED_MODULE_3__.equals)(p.y, Math.min(edge.a.y, edge.b.y)) || ((0,_geometry_js__WEBPACK_IMPORTED_MODULE_3__.equals)(p.y, Math.max(edge.a.y, edge.b.y)) && !(0,_geometry_js__WEBPACK_IMPORTED_MODULE_3__.equals)(edge.a.y, edge.b.y))) {\n          count += 1\n        }\n      };\n    }\n    if (count % 2 == 1) return this.counterclockwise;\n    return this.clockwise;\n  }\n\n  contains(peer) {\n    for (let v = 0; v < peer.vertices.length; v++) {\n      if (!this.containsPoint(peer.vertices[v])) return false\n    }\n    return true\n  }\n\n  /** Check if peer overlaps this structure. Edge shared structures are considered overlapping as\n   * well as vertex overlapping structures.\n   * @todo Structures within `minNumber()` should be considered overlapping.\n   * @param {Polygon} peer\n   * @returns {boolean}\n   */\n  overlaps(peer) {\n    let distSqrdToPeer = _segment_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].distanceSqrd(this.circumcenter, peer.circumcenter);\n    if (distSqrdToPeer >= Math.pow(this.circumradius + peer.circumradius, 2)) return false;\n\n    return this.edges.some(edge => peer.edges.some(peerEdge => edge.intersects(peerEdge)));\n  }\n\n  /** Reverses the vertex order and, therefore, the clockwise state. */\n  reverse() {\n    this._vertices.reverse();\n    this._vertices.splice(0, 0, this._vertices.pop())\n    this._edges = undefined;\n    this._clockwise = !this._clockwise;\n    return this;\n  }\n\n  /**\n   * Joins two overlapping polygons together. Does not affect either polygons,\n   * the new polygon union will be returned or undefined if they don't overlap.\n   */\n  union(peer) {\n    let self = this;\n\n    const builder = {\n      vertices: [],\n      get lastVertex() {\n        return this.vertices[this.vertices.length - 1];\n      }\n    }\n    const tracer = {\n      structure: undefined,\n      iVertex: undefined,\n      get iVertexNext() { return (this.iVertex + 1) % this.structure.vertices.length; },\n      get vertex() { return this.structure.vertices[this.iVertex]; },\n      get vertexNext() { return this.structure.vertices[this.iVertexNext]; },\n      get structureOther() { return this.structure === self ? peer : self; },\n      /** Flip structure from `peer` to `this`, or vice versa, and update iVertex with given index. */\n      structureFlip(index) {\n        this.structure = this.structureOther;\n        this.iVertex = index;\n      }\n    }\n\n    // Start tracer on first outer vertex by index\n    tracer.iVertex = this.vertices.findIndex(vertex => !peer.containsPoint(vertex));\n    if (tracer.iVertex === -1) {\n      // `this` structure is fully contained by `peer`, find outer peer vertex\n      tracer.iVertex = peer.vertices.findIndex(vertex => !this.containsPoint(vertex));\n      tracer.structure = peer;\n    } else {\n      tracer.structure = this;\n    }\n    builder.vertices.push(tracer.vertex);\n\n    // Begin tracing\n    const startingVertex = builder.lastVertex;\n    do {\n      let edge = new _segment_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](builder.lastVertex, tracer.vertexNext);\n      // Overlapping vertices can cause intersection point to be on top of the next vertex\n      if (builder.lastVertex.equals(tracer.vertexNext)) {\n        tracer.iVertex = tracer.iVertexNext;\n        continue;\n      }\n\n      // Check for edge intersections on other structure\n      let intersectionOtherIndices = tracer.structureOther.edges.reduce((found, otherEdge, iOtherEdge) => {\n        if (otherEdge.intersects(edge)) found.push(iOtherEdge);\n        return found;\n      }, []);\n\n      if (intersectionOtherIndices.length === 0) {\n        // No intersections, continue to next vertex on current structure\n        tracer.iVertex = tracer.iVertexNext;\n        builder.vertices.push(tracer.vertex);\n        continue;\n      }\n\n      // Get intersection point closest to current vertex\n      let closestIntersection = intersectionOtherIndices.reduce((prev, iOtherEdge) => {\n        let intersectionPoint = tracer.structureOther.edges[iOtherEdge].intersectionPoint(edge);\n        if (intersectionPoint === undefined) { // Parallel lines\n          intersectionPoint = tracer.structureOther.edges[iOtherEdge].b; // TODO assumes both CCW structures\n        }\n        if (intersectionPoint.equals(builder.lastVertex)) return prev;\n        let distSqrd = _segment_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].distanceSqrd(intersectionPoint, builder.lastVertex);\n        // TODO - verify we're not taking intersection points that are on the edge - or maybe we need those\n        if (distSqrd < prev.distSqrd) return {distSqrd, point: intersectionPoint, index: iOtherEdge};\n        return prev;\n      }, {distSqrd: Infinity});\n\n      if (closestIntersection.point === undefined) {\n        // Intersection is collinear, continue to next vertex on current structure\n        tracer.iVertex = tracer.iVertexNext;\n        builder.vertices.push(tracer.vertex);\n        continue;\n      }\n\n      builder.vertices.push(closestIntersection.point);\n      tracer.structureFlip(closestIntersection.index);\n\n      // Clean way to tell we've reached back to our starting position. Handles the\n      // case where the final edge needs to be checked (tracer.nextVertex === startingVertex)\n      // and case where intersection point flips to structure \"A\" last\n      // edge (tracer.vertex === startingVertex). So let last vertex be pushed then pop.\n    } while (builder.lastVertex !== startingVertex);\n    builder.vertices.pop()\n\n    return new Polygon(builder.vertices);\n  }\n\n  /**\n   * Finds the shortest segment out of the polygon from a starting point.\n   * @param {Point} point starting point\n   * @param {Number} extrudeAmount optional. defaults to smallest amount possible\n   * @returns {Point} shortest Point out of polygon, or the starting point if not within polygon\n   */\n  closestPointOutsideFrom(point, extrudeAmount = undefined) {\n    if (!this.containsPoint(point)) return point;\n\n    let closest = this.edges.reduce((smallest, edge, i) => {\n      if (smallest.distSqrd === 0) return smallest;\n      let closestOnSegment = edge.closestPointToPoint(point);\n      let escapeSegment = new _segment_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](point, closestOnSegment);\n      if (point.equals(closestOnSegment)) return {distSqrd: 0, escapeSegment, vIndex: i};\n      let distSqrd = escapeSegment.distanceSqrd();\n      return distSqrd < smallest.distSqrd ? {distSqrd, escapeSegment, vIndex: i} : smallest;\n    }, {distSqrd: Infinity});\n\n    if (extrudeAmount === undefined) {\n      // The point should be extended out by the smallest amount possible that fails `containsPoint`.\n      // minNumber() gives the smallest floating point precision we can add to a Number but this must\n      // be offset by the magnitude of the input Point's components, as this cuts into the floating\n      // point's decimal precision.\n      extrudeAmount = (0,_geometry_js__WEBPACK_IMPORTED_MODULE_3__.minNumber)(Math.max(Math.abs(point.x), Math.abs(point.y)));\n    }\n    // TODO - extrude could end up back inside polygon\n\n    // On edge\n    if ((0,_geometry_js__WEBPACK_IMPORTED_MODULE_3__.equals)(closest.distSqrd, 0)) {\n      let extendVector;\n      // On endpoint A, extendBy outer angle of vertex\n      if (this.edges[closest.vIndex].a.equals(closest.escapeSegment.b)) {\n        let outerAngle = (0,_geometry_js__WEBPACK_IMPORTED_MODULE_3__.boundAngle)(2 * Math.PI - this.interiorAngleVertex(closest.vIndex));\n        let iPrev = closest.vIndex === 0 ? this.vertices.length - 1 : closest.vIndex - 1;\n        // extendVector = new Vector({magnitude: 1, angle: boundAngle(this.edges[iPrev].angle - outerAngle / 2)});\n        extendVector = new _vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({magnitude: 1, angle: (0,_geometry_js__WEBPACK_IMPORTED_MODULE_3__.boundAngle)(this.edges[iPrev].vector.copy.flip().angle + outerAngle / 2)});\n      }\n      // On endpoint B, extendBy outer angle of vertex\n      else if (this.edges[closest.vIndex].b.equals(closest.escapeSegment.b)) {\n        let outerAngle = (0,_geometry_js__WEBPACK_IMPORTED_MODULE_3__.boundAngle)(2 * Math.PI - this.interiorAngleVertex((closest.vIndex + 1) % this.vertices.length));\n        extendVector = new _vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({magnitude: 1, angle: (0,_geometry_js__WEBPACK_IMPORTED_MODULE_3__.boundAngle)(this.edges[closest.vIndex].vector.copy.flip().angle + outerAngle / 2)});\n      }\n      // On edge, extendBy edge normal\n      else {\n        extendVector = this.edges[closest.vIndex].vector.normal();\n        if (this.clockwise) extendVector.flip();\n      }\n      extendVector.magnitude = extrudeAmount;\n      return point.copy.add(extendVector);\n    }\n    return point.copy.add(closest.escapeSegment.vector.extendBy(extrudeAmount));\n  }\n\n  /**\n   * Get the interior angle of the vertex within the polygon.\n   *\n   * @param Vertex vertex is a vertex object in the polygon's vertices array or an int\n   * for the index number of the vertex to return the angle for.\n   *\n   * @returns the angle in radians of the edges meeting at the vector\n   */\n  interiorAngleVertex(vertex) {\n    let v = (typeof vertex === 'number') ? vertex : this.vertices.indexOf(vertex)\n    vertex = this.vertices[v]\n    let vPrev = this.vertices[(v - 1) < 0 ? this.vertices.length - 1 : (v - 1)]\n    let vNext = this.vertices[(v + 1) % this.vertices.length]\n    let toPrev = new _vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](vPrev.x - vertex.x, vPrev.y - vertex.y)\n    let toNext = new _vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](vNext.x - vertex.x, vNext.y - vertex.y)\n    let dAngle = toPrev.angle - toNext.angle;\n    return this.clockwise ? (0,_geometry_js__WEBPACK_IMPORTED_MODULE_3__.boundAngle)(2 * Math.PI - dAngle) : (0,_geometry_js__WEBPACK_IMPORTED_MODULE_3__.boundAngle)(dAngle);\n  }\n\n  /**\n   * Extrude polygon vertices. An approximation of padding or \"stroking\" a polygon.\n   * @returns {Polyon} with extruded vertices from target\n   */\n  extrudeVertices(extrudeAmount) {\n    if ((0,_geometry_js__WEBPACK_IMPORTED_MODULE_3__.equals)(extrudeAmount, 0)) return this.copy;\n    let extrudedVertices = [];\n    for (let v = 0; v < this.vertices.length; v++) {\n      let cV = this.vertices[v];\n      let nV = this.vertices[(v+1) % this.vertices.length];\n      let pV = this.vertices[(v-1) < 0 ? (this.vertices.length+(v-1)) : (v-1)];\n      // Vectors from current vertex out to previous and next vertex.\n      let pVec = (new _vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](pV.x - cV.x, pV.y - cV.y)).normalize();\n      let nVec = (new _vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](nV.x - cV.x, nV.y - cV.y)).normalize();\n      let angle = Math.acos(pVec.dotProduct(nVec));\n      let cross = pVec.crossProduct(nVec);\n      if (cross <= 0) angle = 2*Math.PI - angle\n      let angleBetween = pVec.angle + angle / 2;\n      extrudedVertices.push(\n        new _point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\n          cV.x + extrudeAmount * Math.cos(angleBetween),\n          cV.y + extrudeAmount * Math.sin(angleBetween)\n        )\n      );\n    }\n    return new Polygon(extrudedVertices);\n  }\n\n  /** Check if the polygon is convex. Memoized. @returns {bool} */\n  convex() {\n    return !this.concave()\n  }\n\n  /** Check if the polygon is concave. Memoized. @returns {bool} */\n  concave() {\n    if (this._concave === undefined) {\n      this._concave = this.vertices.some(v => this.interiorAngleVertex(v) > Math.PI);\n    }\n    return this._concave;\n  }\n\n  logString() {\n    return this.vertices.map(vertex => vertex.logString()).join(' ');\n  }\n\n  /** Gets plain JS object used for serialization. @returns {[Object]}*/\n  json() {\n    return this.vertices.map(vertex => vertex.json());\n  }\n\n  /** Compare vertices between structures @param {Polygon} peer @returns {boolean} */\n  equals(peer) {\n    return this.vertices.every((vertex, i) => vertex.equals(peer.vertices[i]));\n  }\n}\n\n\n//# sourceURL=webpack://js-2d-pathing/./node_modules/@harxer/geometry/lib/structures/polygon.js?");

/***/ }),

/***/ "./node_modules/@harxer/geometry/lib/structures/segment.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@harxer/geometry/lib/structures/segment.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Segment)\n/* harmony export */ });\n/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.js */ \"./node_modules/@harxer/geometry/lib/structures/point.js\");\n/* harmony import */ var _vector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vector.js */ \"./node_modules/@harxer/geometry/lib/structures/vector.js\");\n/* harmony import */ var _geometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry.js */ \"./node_modules/@harxer/geometry/lib/geometry.js\");\n\n\n\n\n// TODO can be arranged as two points or Point/Vector\n\n/** `this._a`, `this._b` populated */\nconst POINT_TO_POINT = \"point_to_point\";\n/** `this._a`, `this._vector` populated */\nconst POINT_VECTOR = \"point_vector\";\n\n/**\n * Structure representing a line bounded by two vertices. Vertices for construction\n * can be Point structures (or object with x/y keys with numeric value). Vertex 2 (or \"B\")\n * can be a vector in which case the Vertex (or \"A\") will be treated as the origin.\n * TODO ? Structure endpoints A and B are stored as frozen copies of Points.\n * Getting A or B will return frozen Point copies to raise an error (in strict mode)\n * when attempting to manipulate endpoints.\n */\nclass Segment {\n  /**\n   * @param {Point | {x: int, y: int}} vertex1\n   * @param {Point | {x: int, y: int} | Vector | {magnitude: int, angle: int}} vertex2\n   */\n  constructor(vertex1, vertex2) {\n    if (_point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].typeOf(vertex1)) {\n      if (!(0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.validNumber)(vertex1.x)) throw Error(`[SEGMENT INIT ERROR]: Vertex 1 X not an integer: ${vertex1.x}`);\n      if (!(0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.validNumber)(vertex1.y)) throw Error(`[SEGMENT INIT ERROR]: Vertex 1 Y not an integer: ${vertex1.y}`);\n      vertex1 = new _point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](vertex1.x, vertex1.y);\n    } else {\n      throw Error(`[SEGMENT INIT ERROR]: Vertex 1 not viable construction point: ${vertex1}`);\n    }\n    this._a = vertex1;\n    Object.freeze(this._a);\n\n    // TODO remove usage of instanceof\n    if (vertex2 instanceof _point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n      this._b = vertex2.copy;\n      Object.freeze(this._b);\n    } else if (vertex2 instanceof _vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n      this._vector = vertex2.copy;\n    } else if (typeof vertex2 === 'object') {\n      if (vertex2.x !== undefined && vertex2.y !== undefined) {\n        if (!(0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.validNumber)(vertex2.x)) throw Error(`[SEGMENT INIT ERROR]: Vertex 2 X not an integer: ${vertex2.x}`);\n        if (!(0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.validNumber)(vertex2.y)) throw Error(`[SEGMENT INIT ERROR]: Vertex 2 Y not an integer: ${vertex2.y}`);\n        this._b = new _point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](vertex2.x, vertex2.y);\n        Object.freeze(this._b);\n      } else if (vertex2.magnitude !== undefined && vertex2.angle !== undefined) {\n        this._vector = new _vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](vertex2);\n      } else {\n        throw Error(`[SEGMENT INIT ERROR]: Vertex 2 not viable construction point: ${vertex2}`);\n      }\n    } else {\n      throw Error(`[SEGMENT INIT ERROR]: Vertex 2 not viable construction point: ${vertex2}`);\n    }\n\n    // TODO - should throw on segment a === b? disallow zero magnitude?\n  }\n\n  // ------------------------ Properties\n\n  /** Origin vertex of structure. @returns {Point} Immutable (frozen) */\n  get a() {\n    return this._a;\n  }\n  set a(val) {\n    if (!_point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].typeOf(val)) throw Error(`[ERROR ASSIGN origin]: Non-point vertex: ${val}`);\n    this.b; // Force `b` generation if moving `a` as this invalidates `_vector`.\n    this._vector = undefined;\n    this._a = new _point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](val.x, val.y);\n  }\n\n  /** @alias a */\n  get origin() { return this.a; }\n  set origin(val) { this.a = val; }\n\n  /** Target vertex of segment. @returns {Point} Immutable (frozen) */\n  get b() {\n    this._b ??= this._a.copy.add(this._vector);\n    return this._b;\n  }\n  set b(val) {\n    if (!_point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].typeOf(val)) throw Error(`[ERROR ASSIGN target]: Non-point vertex: ${val}`);\n    this._b = val;\n    this._vector = undefined;\n  }\n\n  /** Structure as a vector from A to B with origin (0,0). @returns {Vector} Origin (0,0). */\n  get vector() {\n    this._vector ??= this._b.copy.minus(this._a).vector;\n    return this._vector;\n  }\n  set vector(_) { throw Error('Cannot set vector of a Segment structure.') }\n\n  /** Length of segment. @returns {int} */\n  get magnitude() { return this.vector.magnitude; }\n  set magnitude(_) { throw Error('Cannot set magnitude of a Segment structure.') }\n  /** @alias magnitude */\n  get distance() { return this.magnitude; }\n  set distance(_) { throw Error('Cannot set distance of a Segment structure.') }\n  /** @alias magnitude */\n  get length() { return this.magnitude; }\n  set length(_) { throw Error('Cannot set length of a Segment structure.') }\n\n  /** Get structure angle from A to B. @returns {Int} Radians */\n  get angle() { return this.vector.angle; }\n  set angle(_) { throw Error('Cannot set angle of a Segment structure.') }\n\n  /** Copies segments available properties . @returns {Segment} */\n  get copy() {\n    let copySegment;\n    if (this._arrangedAs(POINT_TO_POINT)) {\n      copySegment = new Segment(this._a, this._b);\n    } else {\n      copySegment = new Segment(this._a, this._vector);\n    }\n    return copySegment\n  }\n\n  get slope() {\n    return (this.b.y - this.a.y) / (this.b.x - this.a.x);\n  }\n  set slope(_) { throw Error('Cannot set slope of a Segment structure.') }\n\n  // ------------------------ Functions\n\n  /** Swaps structure's endpoints. `b` becomes the new origin. @returns {this} */\n  flip() {\n    let hold = this._a;\n    this._a = this._b;\n    this._b = hold;\n    if (this._vector !== undefined) this.vector.flip();\n    return this;\n  }\n\n  /** Checks target's A and B with peer's A and B. @param {Segment} peer @returns {boolean} */\n  equals(peer, precision = undefined) {\n    return this._a.equals(peer._a, precision) && this._b.equals(peer._b, precision);\n  }\n\n  /** Structure stringified for readability. @returns {string} \"(x,y) -> (x,y)\" or \"(x,y) plus <vector>\" */\n  logString() {\n    if (this._arrangedAs(POINT_TO_POINT)) {\n      return this._a.logString() + \" -> \" + this._b.logString();\n    }\n    return this._a.logString() + \" plus \" + this._vector.logString();\n  }\n\n  /** Middle point between A and B. @returns {Point} */\n  midpoint() {\n    let dX = this.b.x - this._a.x\n    let dY = this.b.y - this._a.y\n    return new _point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this._a.x + dX/2, this._a.y + dY/2)\n  }\n\n  /** Retrieves length squared. Useful if comparing relative distances. Faster than getting `distance`. @returns {int} */\n  distanceSqrd() {\n    return this.vector.magnitudeSqrd();\n  }\n\n  // https://www.codeproject.com/Tips/862988/Find-the-Intersection-Point-of-Two-Line-Segments\n  // Returns a point or undefined where the two segments intersect. If only need\n  // true of false if two segments intersect, use intersects(). Will return undefined\n  // if end points match\n  intersectionPoint(segment) {\n    // Check for end points matching\n    if (this.a.equals(segment.a) || this.a.equals(segment.b)) {\n      return this.a.copy; // shared endpoints\n    }\n    if (this.b.equals(segment.a) || this.b.equals(segment.b)) {\n      return this.b.copy; // shared endpoints\n    }\n\n    let vOrigins = segment.a.copy.minus(this.a).vector;\n    let cross = this.vector.crossProduct(segment.vector);\n    let crossOrigin = vOrigins.crossProduct(this.vector);\n\n    if ((0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.equals)(cross, 0) && (0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.equals)(crossOrigin, 0)) {\n      return undefined; // collinear segments\n    }\n    if ((0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.equals)(cross, 0) && !(0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.equals)(crossOrigin, 0)) {\n      return undefined; // parallel\n    }\n\n    let t = vOrigins.crossProduct(segment.vector) / cross;\n    let u = crossOrigin / cross;\n\n    if (!(0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.equals)(cross, 0) && ((0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.equals)(t, 0) || (0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.equals)(1, t) || (0 <= t && t <= 1)) && ((0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.equals)(u, 0) || (0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.equals)(u, t) || (0 <= u && u <= 1))) {\n      return new _point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]( // Intersection\n        (this.a.x + this.vector.x * t),\n        (this.a.y + this.vector.y * t)\n      );\n    }\n    return undefined; // No intersection\n  }\n\n  /** Check for segment overlap. Faster than `intersectionPoint()`.\n   * @param {Segment} segment\n   * @returns {boolean} true if segments overlap including endpoints\n   */\n  intersects(segment) {\n    let o1 = (0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.orientation)(this._a, this._b, segment._a);\n    let o2 = (0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.orientation)(this._a, this._b, segment._b);\n    let o3 = (0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.orientation)(segment._a, segment._b, this._a);\n    let o4 = (0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.orientation)(segment._a, segment._b, this._b);\n    // General Cases:\n    if (o1 != o2 && o3 != o4) return true\n    // Special Cases:\n    if (o1 == _geometry_js__WEBPACK_IMPORTED_MODULE_2__.ORIENTATION.COLLINEAR && segment._a.isOnSegment(this)) return true;\n    if (o2 == _geometry_js__WEBPACK_IMPORTED_MODULE_2__.ORIENTATION.COLLINEAR && segment._b.isOnSegment(this)) return true;\n    if (o3 == _geometry_js__WEBPACK_IMPORTED_MODULE_2__.ORIENTATION.COLLINEAR && this._a.isOnSegment(segment)) return true;\n    if (o4 == _geometry_js__WEBPACK_IMPORTED_MODULE_2__.ORIENTATION.COLLINEAR && this._b.isOnSegment(segment)) return true;\n    // Doesn't satisfy any cases:\n    return false;\n  }\n\n  /**\n   * Determine the side which a point lies based on direction of a segment from A to B.\n   * Technically, this is the cross product between this segment and a segment from A to the point.\n   * @param {Point} point The point to check which side it lies on in reference to the segment.\n   * @returns {Integer} A positive value (1) indicates the left side, a negative value (-1) the right side. 0 if point lies on the segment.\n   */\n  directionTo(point) {\n    let cross = this.vector.crossProduct(_vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromSegment(this._a, point));\n    if (cross > 0) return 1;\n    if (cross < 0) return -1;\n    return 0;\n  }\n\n  // TODO - can rewrite cheaper and, additionally, returns ratio (interpolation) of point on segment (t) for free.\n  /** Compute point on Segment closest to given point. @param {Point} point @returns {Point} */\n  closestPointToPoint(point) {\n    if (point.equals(this._a)) return point.copy;\n    let aToPoint = new Segment(this._a, point);\n    let proj = aToPoint.vector.projection(this.vector);\n    // Check if closer to segments endpoints\n    if (proj.quadrant() != this.vector.quadrant()) return this._a;\n    if (this.distanceSqrd() < proj.magnitudeSqrd()) return this._b;\n    return this._a.copy.add(proj);\n  }\n\n  /**\n   * Get the closest points between two segments. This can be intersection point, endpoints,\n   * intermediary point, or arbitrary clamped point if parallel.\n   * @param {Segment} peer\n   * @returns {{aInterp: int, bInterp: int, aClose: Point, bClose: Point}} The closest\n   * point on each segment and the interpolated value along each segment in [0, 1].\n   *\n   * @author [Christer Ericson's Real Time Collision Detection - 5.1.9 (p. 148)]\n   */\n  closestPointToSegment(peer) {\n    let d1 = this.vector;\n    let d2 = peer.vector;\n    let r = _vector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromSegment(d1.a, d2.a);\n    let a = d1.dotProduct(d1);\n    let e = d2.dotProduct(d2);\n    let f = d2.dotProduct(r);\n    // Case: A/B are points (degenerate case, check in ctor)\n    if ((0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.equals)(a, 0) && (0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.equals)(e, 0)) return {aInterp: 0, bInterp: 0, aClose: d1.a, bClose: d2.a};\n\n    let aInterp, bInterp;\n    if ((0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.equals)(a, 0)) {\n      // Case: Segment A is a point (degenerate case, check in ctor)\n      aInterp = 0;\n      bInterp = (0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(f / e, 0, 1);\n    } else {\n      let c = d1.dotProduct(r);\n      if ((0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.equals)(e, 0)) {\n        // Case: Segment B is a point (degenerate case, check in ctor)\n        aInterp = (0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.clamp)(-c / a, 0, 1);\n        bInterp = 0;\n      } else {\n        // General case\n        let b = d1.dotProduct(b);\n        let denominator = a * e - b * b;\n\n        // Check segments not parallel, pick closest on A/B line and clamp to A\n        if (!(0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.equals)(denominator, 0)) {\n          aInterp = (0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.clamp)((b * f - c * e) / denominator, 0, 1);\n        } else {\n          // Any aInterp can be set here (choosing 0)\n          aInterp = 0;\n        }\n\n        bInterp = ( b * s + f) / e;\n\n        if (bInterp < 0) {\n          aInterp = (0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.clamp)( -c / a, 0, 1);\n          bInterp = 0;\n        } else if (bInterp > 1) {\n          s = (0,_geometry_js__WEBPACK_IMPORTED_MODULE_2__.clamp)((b - c) / a, 0, 1);\n          t = 1;\n        }\n      }\n    }\n    return {\n      aInterp, bInterp,\n      aClose: this.a.copy.add(d1.multiplyBy(aInterp)),\n      bClose: peer.a.copy.add(d2.multiplyBy(bInterp))\n    };\n  }\n\n  // --------------------- Static methods\n\n  /** Retrieves length squared between points. @param {Point} a @param {Point} b @returns {int} Length squared */\n  static distanceSqrd(a, b) {\n    return new Segment(a, b).distanceSqrd();\n  }\n\n  /** Retrieves length between points. @param {Point} a @param {Point} b @returns {int} Length */\n  static distance(a, b) {\n    return new Segment(a, b).distance;\n  }\n\n  /**\n   * Determine if given object behaves like a segment.\n   * @param {*} testStructure\n   * @returns {boolean} true if testStructure has an `a` and `b` with `x` and `y`.\n   */\n  static typeOf(testStructure) {\n    return testStructure?.a?.x !== undefined\n      && testStructure?.a?.y != undefined\n      && testStructure?.b?.x != undefined\n      && testStructure?.b?.y != undefined;\n  }\n\n  // --------------------- Internal methods\n\n  /** INTERNAL: Check for valid arrangement style */\n  _arrangedAs(arrangement) {\n    if (arrangement === POINT_TO_POINT) {\n      return this._a !== undefined && this._b !== undefined;\n    }\n    if (arrangement === POINT_VECTOR) {\n      return this._a !== undefined && this._vector !== undefined;\n    }\n  }\n}\n\n\n//# sourceURL=webpack://js-2d-pathing/./node_modules/@harxer/geometry/lib/structures/segment.js?");

/***/ }),

/***/ "./node_modules/@harxer/geometry/lib/structures/vector.js":
/*!****************************************************************!*\
  !*** ./node_modules/@harxer/geometry/lib/structures/vector.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Vector)\n/* harmony export */ });\n/* harmony import */ var _geometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry.js */ \"./node_modules/@harxer/geometry/lib/geometry.js\");\n/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point.js */ \"./node_modules/@harxer/geometry/lib/structures/point.js\");\n\n\n\n// TODO technically only need to preserve any 2 of the 4 properties to compute the others.\n\n/** `this._magnitude`, `this._angle` populated */\nconst MAGNITUDE_ANGLE = \"magnitude_angle\"; // magnitude, angle\n/** `this._x`, `this._y` populated */\nconst COMPONENTS = \"components\"; // x, y\n/** Cannot retrieve angle of a component-arranged zero vector */\nconst ZERO_VECTOR = \"zero_vector\";\n\n// TODO - How to handle angle of zero-length vector?\n// Proposal 1: Allow zero-length vectors but throw error if retrieving angle?\n\n/**\n * Structure representing a direction in space. Can be in the form of an x/y component or\n * a magnitude/angle assuming the origin is (0,0). Magnitude is always positive.\n * Zero component vectors are not allowed unless a vector is zeroed after being able\n * to preserve its angle.\n */\nclass Vector {\n  /**\n   * @param {int | {magnitude: int, angle: int}} arg1 X value or object of magnitude/angle.\n   * @param {int?} arg2 Y value if arg1 is not an object with magnitude/angle.\n   *\n   * @examples\n   * - `new Vector(2, 4)`\n   * - `new Vector({magnitude: 5, angle: PI})`\n   */\n  constructor(arg1, arg2) {\n    // constructor 1: arg1 - {magnitude: {int}, angle: {int}}\n    if (typeof arg1 === 'object') {\n      if (!(0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.validNumber)(arg1.magnitude)) throw Error(`[VECTOR INIT ERROR]: Magnitude not an integer: ${arg1.magnitude}`);\n      if (!Number.isFinite(arg1.angle)) throw Error(`[VECTOR INIT ERROR]: Angle not an integer: ${arg1.angle}`);\n      this._magnitude = arg1.magnitude;\n      this._angle = arg1.angle;\n      // Maintain positive magnitude\n      if (this._magnitude < 0) {\n        this._magnitude *= -1;\n         // TODO - Does angle bounding need to happen? Can wait until its needed in a getter or usage in `equals`. It may break TENANT-2.\n        this._angle = (0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.boundAngle)(arg1.angle + Math.PI);\n      }\n      return;\n    }\n    // constructor 2: arg1 {int}, arg2 {int}\n    if (!(0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.validNumber)(arg1)) throw Error(`[VECTOR INIT ERROR]: X component not an integer: ${arg1}`);\n    if (!(0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.validNumber)(arg2)) throw Error(`[VECTOR INIT ERROR]: Y component not an integer: ${arg2}`);\n    this._x = arg1;\n    this._y = arg2;\n  }\n\n  // ------------------------ Properties\n\n  /** Structure's x component. @returns {integer} */\n  get x() {\n    // Defer extract x component if structure only has a magnitude and angle\n    if (this._x === undefined)  {\n      if (this._magnitude === 0) {\n        // Zero vectors do not memoize components to zero.\n        // If memo fields for _x and _y were seen as zero, the structure may be treated as\n        // a component-arranged zero vector which is not allowed (see Vector class description).\n        return 0;\n      } else {\n        this._x = this.magnitude * Math.cos(this.angle)\n      }\n    };\n    return this._x;\n  }\n  set x(val) {\n    if (!(0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.validNumber)(val)) throw Error(`Cannot set x component to non-integer: ${val}`);\n    if ((0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.equals)(this._x, val)) return;\n    if (val === 0 && this._y === 0) {\n      // Save angle before zeroing components\n      this.angle;\n      this._magnitude = 0;\n      this._x = undefined;\n      this._y = undefined;\n    } else if (this._magnitude === 0) {\n      // Handle zero vector component setting\n      this._y = 0;\n      this._x = val\n      this._magnitude = val;\n      this._angle = undefined;\n    } else {\n      // Force compute y before clearing magnitude/angle\n      this.y;\n      this._angle = undefined;\n      this._x = val;\n      this._magnitude = undefined;\n    }\n  }\n\n  /** Structure's y component. @returns {integer} */\n  get y() {\n    // Defer extract y component if structure only has a magnitude and angle\n    if (this._y === undefined) {\n      if (this._magnitude === 0) {\n        // Zero vectors do not memoize components to zero.\n        // If memo fields for _x and _y were seen as zero, the structure may be treated as\n        // a component-arranged zero vector which is not allowed (see Vector class description).\n        return 0;\n      } else {\n        this._y = this.magnitude * Math.sin(this.angle)\n      }\n    }\n    return this._y;\n  }\n  set y(val) {\n    if (!(0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.validNumber)(val)) throw Error(`Cannot set y component to non-integer: ${val}`);\n    if ((0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.equals)(this._y, val)) return;\n    if (val === 0 && this._x === 0) {\n      // Save angle before zeroing components\n      this.angle;\n      this._magnitude = 0;\n      this._x = undefined;\n      this._y = undefined;\n    } else if (this._magnitude === 0) {\n      // Handle zero vector component setting\n      this._x = 0\n      this._y = val;\n      this._magnitude = val;\n      this._angle = undefined;\n    } else {\n      // Force compute x before clearing magnitude/angle\n      this.x;\n      this._angle = undefined;\n      this._y = val;\n      this._magnitude = undefined;\n    }\n  }\n\n  /** Length of structure, assuming origin (0,0). @returns {integer} */\n  get magnitude() {\n    if (this._magnitude === undefined) this._magnitude = Math.sqrt(Math.pow(this._x, 2) + Math.pow(this._y, 2));\n    return this._magnitude;\n  }\n  /**\n   * Update length of vector. Assigning a negative magnitude will flip the angle and\n   * enforce a positive magnitude. Setting zero magnitude maintains last computable angle\n   * and zeroes components.\n   */\n  set magnitude(val) {\n    if (!(0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.validNumber)(val)) throw Error(`Cannot set magnitude to non-integer: ${val}`);\n    if ((0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.equals)(this._magnitude, val)) return;\n\n    if (this._magnitude !== undefined) {\n      // If previous magnitude saved with components, rescale x/y components\n      if (this._arrangedAs(COMPONENTS)) {\n        // Preserve angle if zeroing magnitude\n        if (val === 0) {\n          this.angle;\n          this._x = undefined;\n          this._y = undefined;\n        } else {\n          let magnitudeScaling = val / this._magnitude;\n          this._x *= magnitudeScaling;\n          this._y *= magnitudeScaling;\n        }\n      } else {\n        // defer x/y component generation\n        this._x = undefined;\n        this._y = undefined;\n      }\n    } else {\n      this.angle;\n      this._x = undefined;\n      this._y = undefined;\n    }\n\n    // Maintain positive magnitude, flip angle\n    if (this._angle !== undefined && val < 0) this.angle = (0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.boundAngle)(this.angle + Math.PI)\n\n    this._magnitude = Math.abs(val);\n  }\n\n  /** Angle of structure, assuming origin (0,0) in radians. @throws X/Y are zero. @returns {integer} radians */\n  get angle() {\n    if (this._angle === undefined) {\n      // Zero-length structure gives 0 angle.\n      if ((0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.equals)(this._x, 0) && (0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.equals)(this._y, 0)) throw Error('Cannot get angle of zero vector.');\n      this._angle = (0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.boundAngle)(Math.atan2(this.y, this.x));\n    }\n    return this._angle;\n  }\n  set angle(val) {\n    if (this._angle === val) return;\n    if (!Number.isFinite(val)) throw Error(`Cannot set angle to non-integer: ${val}`);\n    this._angle = (0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.boundAngle)(val);\n    // force magnitude generation before losing x/y components\n    this.magnitude;\n    this._x = undefined;\n    this._y = undefined;\n  }\n\n  /** Creates a Point structure out of vector components. @returns {Point} */\n  get point() {\n    return new _point_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.x, this.y);\n  }\n\n  /** Copies the target of all set properties */\n  get copy() {\n    if (this._arrangedAs(COMPONENTS)) {\n      let vectorCopy = new Vector(this._x,\n       this._y);\n      vectorCopy._magnitude = this._magnitude;\n      vectorCopy._angle = this._angle;\n      return vectorCopy;\n    } else if (this._x === 0 && this._y === 0) {\n      let zeroVector = new Vector(0, 0);\n      zeroVector._angle = this._angle;\n      zeroVector._magnitude = 0;\n      return zeroVector;\n    }\n    let vectorCopy = new Vector({magnitude: this._magnitude, angle: this._angle});\n    vectorCopy._x = this._x;\n    vectorCopy._y = this._y;\n    return vectorCopy;\n  }\n\n  // ------------------------ Functions\n\n  /** Compares target's properties and peer's properties. @param {Vector} peer @returns {boolean} */\n  equals(peer, precision = undefined) {\n    if (this._arrangedAs(MAGNITUDE_ANGLE) && peer._arrangedAs(MAGNITUDE_ANGLE)) {\n      return (0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.equals)(this.magnitude, peer.magnitude, precision) && (0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.equals)(this.angle, peer.angle, precision);\n    }\n    return (0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.equals)(this.x, peer.x, precision) && (0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.equals)(this.y, peer.y, precision);\n  }\n\n  /** Length of structure multipled by given constant. @param {int} val @returns {this} */\n  multiplyBy(val) {\n    if (this._magnitude !== undefined) this._magnitude *= val;\n    if (this._x !== undefined) this._x *= val;\n    if (this._y !== undefined) this._y *= val;\n    return this;\n  }\n\n  /** Adds value to structure's length. @param {int} peer @returns {this} */\n  extendBy(val) {\n    this.magnitude += val;\n    return this\n  }\n\n  /** Brings magnitude of vector down to zero by value.  */\n  reduceBy(val) {\n    if (this.magnitudeSqrd() > val * val) {\n      this.magnitude -= val;\n    } else {\n      this.magnitude = 0; // TODO may be able to optimize\n    }\n    return this;\n  }\n\n  /** Chainable magnitude setter function. @param {int} magnitude @returns {this}  */\n  length(magnitude) {\n    this.magnitude = magnitude;\n    return this;\n  }\n\n  /** Adds peer structure. @param {Vector} peer @returns {this} */\n  add(peer) {\n    if (peer._arrangedAs(ZERO_VECTOR)) return this;\n    let x = this.x + peer.x;\n    let y = this.y + peer.y;\n    if (x === 0 && y === 0) {\n      // Avoid component-arranged zero vector\n      this.angle;\n      this._magnitude = 0;\n      this._x = undefined;\n      this._y = undefined;\n    } else {\n      this.x = x;\n      this.y = y;\n    }\n    return this;\n  }\n\n  /** Subtracts peer structure. @param {Vector} peer @returns {this} */\n  minus(peer) {\n    if (peer._arrangedAs(ZERO_VECTOR)) return this;\n    let x = this.x - peer.x;\n    let y = this.y - peer.y;\n    if (x === 0 && y === 0) {\n      // Avoid component-arranged zero vector\n      this.angle;\n      this._magnitude = 0;\n      this._x = undefined;\n      this._y = undefined;\n    } else {\n      this.x = x;\n      this.y = y;\n    }\n    return this;\n  }\n\n  /** Slope of structure. @returns {int} */\n  slope() {\n    return (this.y / this.x);\n  }\n\n  /** Flips structure by 180deg. @returns {this} */\n  flip() {\n    if (this._angle !== undefined) this._angle = (0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.boundAngle)(this._angle + Math.PI);\n    if (this._x !== undefined) this._x *= -1;\n    if (this._y !== undefined) this._y *= -1;\n    return this;\n  }\n\n  /** Retrieves magnitude squared - value is not memoized. @returns {int} */\n  magnitudeSqrd() {\n    if (this._magnitude !== undefined) return this._magnitude * this._magnitude;\n    // Same as dotProduct with itself\n    return this._x * this._x + this._y * this._y;\n  }\n\n  /** Structure stringified for readability. @returns {string} \"(x, y) D:(magnitude) A:(angle?)\" */\n  logString() {\n    return `(${this._x}, ${this._y}) D:${this._magnitude} A:${(this._angle === undefined) ? undefined : this._angle / Math.PI * 180}`\n  }\n\n  /** Sets structure length to 1. @returns {this} */\n  normalize() {\n    if (this._arrangedAs(COMPONENTS)) {\n      if ((0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.equals)(this._x, 0)) {\n        this._y = 1 * Math.sign(this._y);\n        this._magnitude = 1;\n        return this;\n      }\n      if ((0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.equals)(this._y, 0)) {\n        this._x = 1 * Math.sign(this._x);\n        this._magnitude = 1;\n        return this;\n      }\n      this.magnitude = 1;\n    } else {\n      this.magnitude = 1;\n    }\n    return this;\n  }\n\n  /** Gets quadrant of angle produced by structure, assuming origin (0,0). @returns {1 | 2 | 3 | 4} */\n  quadrant() {\n    if (this._arrangedAs(MAGNITUDE_ANGLE)) {\n      if (this.angle >= 4.71238898038469) return 4; // > (3/2) * PI\n      if (this.angle >= 3.141592653589793) return 3; // > PI\n      if (this.angle >= 1.5707963267948966) return 2; // > (1/2) * PI\n      return 1;\n    }\n    if (this.x > 0 && this.y >= 0) return 1\n    if (this.x <= 0 && this.y > 0) return 2\n    if (this.x < 0 && this.y <= 0) return 3\n    return 4; // this.x < 0 && this.y >= 0\n  }\n\n  /** Mirrors structure across a given normal. @param {Vector} normal @returns {Vector} new structure */\n  reflect(normal, elasticity = 1, friction = 1) {\n    let proj = this.copy.projection(normal);\n    let perp = this.copy.minus(proj);\n    // apply elasticity and friction\n    return perp.multiplyBy(friction).minus(proj.multiplyBy(elasticity));\n  }\n\n  /** Dot product with peer. @param {Vector} peer @returns {int} */\n  dotProduct(peer) {\n    return this.x * peer.x + this.y * peer.y;\n  }\n\n  /** Cross product with peer (pseudo). Loosely defined in 2D as the magnitude of the 3D cross product. \"perp-dot product\". @param {Vector} peer @returns {int} */\n  crossProduct(peer) {\n    return this.x * peer.y - this.y * peer.x;\n  }\n\n  /** Magnitude of this structure along peer. @param {Vector} peer @returns {Vector} new structure */\n  projection(peer) {\n    if (this._arrangedAs(COMPONENTS) && peer._arrangedAs(COMPONENTS)) {\n      return peer.copy.multiplyBy(this.dotProduct(peer) / peer.magnitudeSqrd());\n    }\n    let peerNormalized = peer.copy.normalize();\n    peerNormalized.magnitude = this.dotProduct(peerNormalized);\n    return peerNormalized;\n  }\n\n  /** Tests structure for bisection of circle by origin and radiusSqrd.\n   * @param {Point} origin of circle\n   * @param {int} radius of circle\n   * @returns {bool} true if structure intersects circle\n   */\n  intersectsCircle(origin, radius) {\n    if (!_point_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].typeOf(origin)) {\n      throw Error(`[ERROR intersectsCircle]: Provided origin is not a valid point: ${origin}`)\n    }\n    if (origin.x === 0 && origin.y === 0) return true;\n    let proj = this.projection(new Vector(origin.x, origin.y));\n    let perp = new _point_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](origin.x, origin.y).minus(proj);\n    if (perp.x === 0 && perp.y === 0) return true;\n    let dotProd = proj.dotProduct(this);\n\n    if (dotProd < 0) return false;\n    if (dotProd > this.magnitudeSqrd()) return false;\n\n    return (perp.vector.magnitudeSqrd() < radius * radius);\n  }\n\n  /** Returns right square angle Vector of this structure. @returns {Vector} */\n  normal() {\n    if (this._arrangedAs(COMPONENTS)) {\n      let newVector = new Vector(this.y, -this.x);\n      if (this._angle !== undefined) newVector._angle = (0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.boundAngle)(this._angle - Math.PI / 2);\n      newVector._magnitude = this._magnitude;\n      return newVector\n    }\n    let newVector = new Vector({magnitude: this.magnitude, angle: (0,_geometry_js__WEBPACK_IMPORTED_MODULE_0__.boundAngle)(this.angle - Math.PI / 2)});\n    newVector._x = this._y;\n    if (this._y !== undefined) newVector._y = -this._x;\n    return newVector;\n  }\n  /** @alias normal */\n  perpendicular() {\n    return this.normal();\n  }\n\n  // --------------------- Static methods\n\n  /** Create vector from two points. */\n  static fromSegment(a, b) {\n    return new Vector(b.x - a.x, b.y - a.y);\n  }\n\n  // --------------------- Internal methods\n\n  /** INTERNAL: Check for valid arrangement style */\n  _arrangedAs(arrangement) {\n    if (arrangement === ZERO_VECTOR) {\n      return (this._x === 0 && this._y === 0);\n    }\n    if (arrangement === COMPONENTS) {\n      return this._x !== undefined &&\n             this._y !== undefined &&\n             // This structure takes special care to avoid having both components set to zero.\n             // See Vector class description for more.\n             (this._x !== 0 || this._y !== 0);\n    }\n    if (arrangement === MAGNITUDE_ANGLE) {\n      return this._angle !== undefined && this._magnitude !== undefined;\n    }\n  }\n\n  // --------------------- Deprecated\n\n  /** @deprecated */\n  multipliedBy() {throw Error('Deprecated');}\n  /** @deprecated */\n  plus() {throw Error('Deprecated');}\n  /** @deprecated */\n  flipped() {throw Error('Deprecated');}\n  /** @deprecated */\n  extendedBy() {throw Error('Deprecated');}\n  /** @deprecated */\n  normalized() { throw Error('Deprecated'); }\n}\n\n\n//# sourceURL=webpack://js-2d-pathing/./node_modules/@harxer/geometry/lib/structures/vector.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./javascript/index.js");
/******/ 	
/******/ })()
;